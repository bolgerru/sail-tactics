<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sail Tactics Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0077be; /* Ocean blue */
            font-family: sans-serif;
            color: white;
            user-select: none;
            -webkit-user-select: none;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            font-size: 1.2rem;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
        }
        #settings-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.3);
            color: white;
            border: 1px solid white;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 5px;
            z-index: 100;
        }
        #settings-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 1000; /* Ensure it's on top of everything including red flag (z-150) and medal (z-200) */
            width: 80%;
            max-width: 300px;
        }
        #settings-modal label {
            display: block;
            margin: 10px 0 5px;
        }
        #settings-modal input, #settings-modal select {
            margin-bottom: 10px;
            width: 100%;
            box-sizing: border-box;
        }
        .sound-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 12px 0;
        }
        .sound-row input {
            width: auto;
            margin: 0;
        }
        .sound-row span {
            color: white;
        }
        #medal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border-radius: 50%;
            display: flex; /* Initially none, handled by JS */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            border: 5px solid white;
            z-index: 200;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            pointer-events: auto; /* Allow clicking to restart */
            cursor: pointer;
        }
        #medal h1 { margin: 0; font-size: 3rem; }
        #start-timer {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 8rem;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
            z-index: 120;
            pointer-events: none;
            width: 100%;
            text-align: center;
        }
        #red-flag-msg {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 68, 68, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            border: 3px solid white;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
            z-index: 150;
            pointer-events: none;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        #black-flag-msg {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            border: 3px solid white;
            z-index: 150;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="ui">
        <!-- Wind text removed, will be drawn on canvas -->
    </div>
    <button id="settings-btn">‚öôÔ∏è Settings</button>
    <div id="settings-modal">
        <h2>Settings</h2>
        
        <label>Wind Speed</label>
        <input type="range" id="opt-speed" min="0.05" max="0.2" step="0.01">

        <label>Number of Boats: <span id="opt-boats-val"></span></label>
        <input type="range" id="opt-boats" min="2" max="10" step="1">

        <label>Difficulty</label>
        <select id="opt-diff">
            <option value="matty">Matty (Easiest)</option>
            <option value="louis">Louis</option>
            <option value="will">Will</option>
            <option value="monkey">Monkey</option>
            <option value="oisin">Oisin</option>
            <option value="max">Max</option>
            <option value="russell">Russell (Hardest)</option>
        </select>

        <label class="sound-row">
            <input type="checkbox" id="opt-sound" checked>
            <span>Sound</span>
        </label>

        <br>
        <button id="save-btn">Save & Restart</button>
    </div>

    <div id="start-timer"></div>
    
    <div id="black-flag-msg">
        üè¥ BLACK FLAG!
    </div>

    <div id="red-flag-msg">
        üö© Eunice:<br>RED FLAG FOR EVERYONE EXCPEPT YOU!
    </div>

    <div id="medal" style="display: none;">
        <h1 id="medal-rank">1st</h1>
        <p id="medal-msg">Congrats!</p>
        <p style="font-size: 0.8rem; margin-top: 10px;">Tap to Restart</p>
    </div>

    <div id="instructions">Tap to Start</div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiInstructions = document.getElementById('instructions');

        // Game State
        let width, height;
        const boats = [];
        let BOAT_SPEED = 0.1; // Configurable
        let boatCount = 3; // Configurable
        let difficulty = 'matty'; // Configurable
        let soundEnabled = true;

        const TACK_ANGLE_RAD = 40 * Math.PI / 180;
        
        // Colors
        const COLOR_USER = '#ffcc00'; // Yellow
        const COLOR_OPPONENT = '#cccccc'; // White/Grey
        
        let gameState = 'waiting'; // waiting, starting, playing, finished
        let startTimer = 3;
        let startInterval = null;
        const START_LINE_Y = 600; // Will be set in resetGame
        let finishedBoatsCount = 0;
        const FINISH_LINE_Y = 100;

        const TURN_SPEED = 0.05; // Radians per frame
        
        // Wind Physics
        let windDirection = 0; // 0 is from Top (North)
        let windTarget = 0;
        // Shift chance per frame (60fps). 0.005 is approx every 3.3s
        const WIND_SHIFT_CHANCE = 0.005; 
        const MAX_WIND_DEVIATION = 30 * Math.PI / 180; // Clamp total deviation
        const MAX_SHIFT = 20 * Math.PI / 180; // Max shift per event

        // Gusts
        const gusts = [];
        const ripples = [];
        const confettiParticles = [];
        const RIPPLE_COUNT = 100;
        const CONFETTI_COUNT = 100;

        const GUST_SPAWN_CHANCE = 0.005; // Much less frequent
        const GUST_MOVE_SPEED = 0.3;
        
        // Sound Manager
        class SoundManager {
            constructor() {
                this.ctx = null;
                this.windGain = null;
                this.isInit = false;
            }

            init() {
                if (this.isInit) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.isInit = true;
                this.startWindNoise();
            }

            playStartBeep(freq = 440) {
                if (!this.ctx || !soundEnabled) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.5);
            }

            playStartGun() {
                if (!this.ctx || !soundEnabled) return;
                const t = this.ctx.currentTime;
                // Short bright beep ‚Äî one sine, ~0.2s, no ramp
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(660, t);
                gain.gain.setValueAtTime(0.4, t);
                gain.gain.setValueAtTime(0.4, t + 0.15);
                gain.gain.linearRampToValueAtTime(0, t + 0.2);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(t);
                osc.stop(t + 0.2);
            }

            playTackSound() {
                if (!this.ctx || !soundEnabled) return;
                // White noise burst
                const bufferSize = this.ctx.sampleRate * 0.2;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();
                // Filter to make it sound like fabric snapping
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 800;

                gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start();
            }

            playSplashSound() {
                if (!this.ctx || !soundEnabled) return;
                // Similar to tack but softer/longer
                 const bufferSize = this.ctx.sampleRate * 0.5;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 400;

                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.4);
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start();
            }

            startWindNoise() {
                if (!this.ctx) return;
                // Continuous pink noise loop
                const bufferSize = this.ctx.sampleRate * 2;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    data[i] = (lastOut + (0.02 * white)) / 1.02;
                    lastOut = data[i];
                    data[i] *= 3.5; 
                }
                // Pink noise approximation logic requires variable persistence, simplified here:
                // Just use brownian-ish noise from above loop (lastOut)
                
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                noise.loop = true;
                
                this.windGain = this.ctx.createGain();
                this.windGain.gain.value = 0.05; // Base volume
                
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 400;

                noise.connect(filter);
                filter.connect(this.windGain);
                this.windGain.connect(this.ctx.destination);
                noise.start();
            }

            setWindVolume(vol) {
                if (this.windGain) {
                    const v = soundEnabled ? vol : 0;
                    this.windGain.gain.setTargetAtTime(v, this.ctx.currentTime, 0.1);
                }
            }
        }
        let lastOut = 0; // For noise generation
        const sfx = new SoundManager();

        class Ripple {
            constructor() {
                this.init();
            }
            
            init() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.life = Math.random(); // 0 to 1
                this.speed = Math.random() * 0.5 + 0.5;
            }

            update() {
                // Move with windDirection
                // WindDirection 0 = Wind from Top = Moves DOWN (Positive Y)
                // Wait, if wind is FROM top, ripples move DOWN.
                // Formula: x += sin(wind) * speed, y += cos(wind) * speed ??
                // windDirection 0 (North): sin(0)=0, -cos(0)=-1 (UP). 
                // But Wind FROM North blows TO South.
                // So dy should be +1.
                // dx = -sin(wind)
                // dy = cos(wind)
                // Let's check wind arrow logic: windDirection 0 -> arrow points down (PI). 
                // So movement is PI rotation of "UP".
                
                // Wind Vector:
                // From North (0) -> Vector (0, 1) [Down]
                // From East (PI/2) -> Vector (-1, 0) [Left]
                // From South (PI) -> Vector (0, -1) [Up]
                
                // x += -sin(windDir) * speed
                // y += cos(windDir) * speed
                
                this.x -= Math.sin(windDirection) * this.speed * 2;
                this.y += Math.cos(windDirection) * this.speed * 2;
                
                this.life -= 0.005;
                if (this.life <= 0 || this.x < -50 || this.x > width + 50 || this.y < -50 || this.y > height + 50) {
                    this.init();
                    // Spawn at edge based on wind? Or just random is fine for "field" effect
                    // Random is easier for continuous field
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(windDirection); // Rotate to match flow
                
                ctx.strokeStyle = `rgba(255, 255, 255, ${this.life * 0.2})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, -5);
                ctx.lineTo(0, 5);
                ctx.stroke();
                
                ctx.restore();
            }
        }
        
        class Confetti {
            constructor() {
                this.reset(true);
            }
            
            reset(startWait = false) {
                this.x = width / 2;
                this.y = height / 2;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 5;
                this.vx = Math.sin(angle) * speed;
                this.vy = Math.cos(angle) * speed;
                this.gravity = 0.2;
                this.friction = 0.98;
                this.life = Math.random() * 100 + 100;
                this.color = `hsl(${Math.random() * 360}, 100%, 50%)`;
                this.rotation = Math.random() * 360;
                this.rotationSpeed = (Math.random() - 0.5) * 10;
                this.active = false;
                if (!startWait) this.active = true;
            }
            
            explode() {
                this.reset(false);
            }
            
            update() {
                if (!this.active) return;
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.vx *= this.friction;
                this.vy *= this.friction;
                this.rotation += this.rotationSpeed;
                this.life--;
                if (this.life <= 0) this.active = false;
            }
            
            draw(ctx) {
                if (!this.active) return;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation * Math.PI / 180);
                ctx.fillStyle = this.color;
                ctx.fillRect(-4, -4, 8, 8);
                ctx.restore();
            }
        }

        class Gust {
            constructor() {
                // Make size proportional to screen size
                // Width: 25% to 40% of screen width
                const minW = width * 0.25;
                const varW = width * 0.15;
                this.width = Math.random() * varW + minW;
                
                // Height: 20% to 40% of screen height
                const minH = height * 0.2;
                const varH = height * 0.2;
                this.height = Math.random() * varH + minH;

                this.x = Math.random() * (width - this.width);
                this.y = -this.height; // Start above screen
                this.strength = Math.random() * 0.2 + 1.1; // Reduced: 1.1x to 1.3x speed boost
                this.active = true;
            }

            update() {
                this.y += GUST_MOVE_SPEED;
                if (this.y > height) {
                    this.active = false;
                }
            }

            draw(ctx) {
                ctx.save();
                
                // Radial gradient for soft edges all around
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                
                // Use a radial gradient scaled to match the ellipse aspect ratio
                // Since createRadialGradient is circular, we'll scale the context
                ctx.translate(centerX, centerY);
                ctx.scale(1, this.height / this.width); // Scale Y to make circle an ellipse
                
                // Use strength to determine opacity
                // Strength ranges 1.2 to 1.6
                // Map to opacity 0.2 to 0.5
                const baseOpacity = 0.2 + (this.strength - 1.2) * 0.75;
                const edgeOpacity = baseOpacity * 0.75;

                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width / 2);
                gradient.addColorStop(0, `rgba(0, 30, 80, ${baseOpacity})`); // Center darker based on strength
                gradient.addColorStop(0.6, `rgba(0, 30, 80, ${edgeOpacity})`); 
                gradient.addColorStop(1, "rgba(0, 30, 80, 0)"); // Fade to transparent

                
                ctx.fillStyle = gradient;
                
                ctx.beginPath();
                ctx.arc(0, 0, this.width / 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }

        class Boat {
            constructor(x, y, isUser = false) {
                this.x = x;
                this.y = y;
                this.isUser = isUser;
                this.tack = 1; // 1 or -1
                this.updateTargetHeading();
                this.heading = this.targetHeading; 
                this.radius = 15;
                this.finished = false;
                this.spinDir = Math.random() < 0.5 ? 1 : -1; // For Will mode
                this.moving = false; // Waiting for start
                this.trail = []; // Wake trail
                this.luffTimer = 0; // For sail animation
                this.dsq = false; // Disqualified flag
                this.lastTackTime = 0;
                this.hailingTarget = null;
                this.hailedBy = null;
                this.hailTimer = 0;
            }

            findTackBlocker() {
                // Determine intended direction
                // If tack is 1 (Rightward), next tack is -1 (Leftward). We are turning Left.
                // We check for boats on the side we are turning towards.
                // Tack 1 -> turning Left (look for boats on Left)
                // Tack -1 -> turning Right (look for boats on Right)
                
                const intendedTack = this.tack * -1;
                const lookLeft = intendedTack === -1; // Turning Left
                
                // Rotate to Wind Space
                // Wind Direction 0 = From Top.
                // Rotate by -windDirection to align Y with Wind (inverted?). 
                // Let's just project onto Cross-Wind Axis and Wind Axis.
                // Wind Vector is (sin(w), -cos(w))? No, arrow points down.
                // Let's rely on standard rotation.
                // Rotate -windDirection.
                // If wind is 0, no rotation. Y is down. X is right.
                // Boat heading 0 is Up (-Y). 
                // Wind from Top (0). Boats sail Up. 
                // "Horizontal" means X-axis. "Vertical" means Y-axis.
                
                const cos = Math.cos(-windDirection);
                const sin = Math.sin(-windDirection);
                
                const myRx = this.x * cos - this.y * sin;
                const myRy = this.x * sin + this.y * cos;
                
                let closest = null;
                let minDist = Infinity;
                
                // Search parameters
                const rangeX = this.radius * 2.5; // Reduced from 4 (closer hailing)
                const rangeY = this.radius * 2; // Strict abeam check
                
                for (const other of boats) {
                    if (other === this || other.finished || other.dsq) continue;
                    
                    const otherRx = other.x * cos - other.y * sin;
                    const otherRy = other.x * sin + other.y * cos;
                    
                    const dx = otherRx - myRx;
                    const dy = Math.abs(otherRy - myRy);
                    
                    // Check Vertical alignment (Abeam)
                    if (dy > rangeY) continue;
                    
                    // Check Horizontal Side and Distance
                    let isBlocked = false;
                    if (lookLeft) {
                        // Look for boat on Left (dx < 0)
                        if (dx < 0 && dx > -rangeX) isBlocked = true;
                    } else {
                        // Look for boat on Right (dx > 0)
                        if (dx > 0 && dx < rangeX) isBlocked = true;
                    }
                    
                    if (isBlocked) {
                        const d = Math.abs(dx);
                        if (d < minDist) {
                            minDist = d;
                            closest = other;
                        }
                    }
                }
                return closest;
            }

            initiateHail(target) {
                if (!target || this.hailingTarget === target) return;
                
                this.hailingTarget = target;
                this.hailingTargetOriginalTack = target.tack; // Track if they moved
                target.hailedBy = this;
                target.hailTimer = 60; // Force reaction for ~1 sec
                
                // If user is target, we might show UI elsewhere
            }

            updateHailingLogic() {
                // 1. Am I hailing someone?
                if (this.hailingTarget) {
                    const target = this.hailingTarget;
                    // Has target tacked away?
                    const stillBlocking = this.findTackBlocker();
                    
                    let shouldClear = false;
                    if (stillBlocking !== target) {
                        shouldClear = true;
                        
                        // BUT: If target hasn't tacked yet, and we are still close, keep the link!
                        // This handles the "forced tack into crash" scenario where we tack but they didn't move.
                        if (target.tack === this.hailingTargetOriginalTack) {
                            const dist = Math.hypot(target.x - this.x, target.y - this.y);
                            if (dist < this.radius * 6) { // Still in proximity
                                shouldClear = false;
                            }
                        }
                    }

                    if (shouldClear) {
                        // Clear!
                        this.hailingTarget = null;
                        if (target) target.hailedBy = null; // Clear their flag
                        
                        if (!this.isUser) {
                            this.tackBoat(true); // Finally tack!
                        }
                    }
                }
                
                // 2. Am I being hailed?
                if (this.hailedBy) {
                    // I must tack soon.
                    // But wait, can I tack?
                    const myBlocker = this.findTackBlocker();
                    
                    if (myBlocker) {
                        // I am blocked too! Chain the hail.
                        this.initiateHail(myBlocker);
                    } else {
                        // I am free to tack.
                        if (!this.isUser) {
                            // AI: Force tack immediately (Rule 20 compliance)
                            this.tackBoat(true);
                        }
                        // User: Do nothing (wait for manual input).
                        // "TACK NOW!" is displayed in draw().
                    }
                }
            }

            isTackingRule() {
                return (Date.now() - this.lastTackTime) < 1000;
            }

            getPolygon() {
                // Vertices relative to center (0,0)
                // Bow: (0, -radius)
                // Rear Right: (0.7 * radius, radius)
                // Rear Left: (-0.7 * radius, radius)
                
                const pts = [
                    {x: 0, y: -this.radius},
                    {x: this.radius * 0.7, y: this.radius},
                    {x: -this.radius * 0.7, y: this.radius}
                ];

                const cos = Math.cos(this.heading);
                const sin = Math.sin(this.heading);

                return pts.map(p => {
                    // Rotate
                    const rx = p.x * cos - p.y * sin;
                    const ry = p.x * sin + p.y * cos;
                    // Translate
                    return {
                        x: this.x + rx,
                        y: this.y + ry
                    };
                });
            }

            updateTargetHeading() {
                // Target is relative to wind direction
                this.targetHeading = windDirection + (this.tack * TACK_ANGLE_RAD);
            }

            update() {
                if (this.finished || !this.moving || this.dsq) return;

                let isTacking = false;

                // Will Mode: Continuous Spin
                if (!this.isUser && difficulty === 'will') {
                    this.heading += this.spinDir * TURN_SPEED;
                    isTacking = true; // Considers turning for speed penalty
                } 
                else {
                    // Normal Logic: Smoothly rotate heading towards targetHeading
                    this.updateTargetHeading(); // Update target based on wind

                    if (this.heading !== this.targetHeading) {
                        isTacking = true;
                        // Handle wrapping logic if we were using 0-360, but here headings are small radians.
                        // Simple difference is fine.
                        const diff = this.targetHeading - this.heading;
                        if (Math.abs(diff) < TURN_SPEED) {
                            this.heading = this.targetHeading;
                            isTacking = false;
                        } else {
                            this.heading += Math.sign(diff) * TURN_SPEED;
                        }
                    }
                }

                // Move boat
                let tackMultiplier = 0.7; // Base speed retention
                
                if (!this.isUser) {
                    // Difficulty-based speed retention during tacks
                    switch(difficulty) {
                        case 'matty': tackMultiplier = 0.6; break;
                        case 'louis': tackMultiplier = 0.7; break;
                        case 'will': tackMultiplier = 0.7; break;
                        case 'monkey': tackMultiplier = 0.8; break;
                        case 'oisin': tackMultiplier = 0.9; break;
                        case 'max': tackMultiplier = 0.95; break;
                        case 'russell': tackMultiplier = 0.98; break;
                    }
                }

                const currentSpeedBase = isTacking ? BOAT_SPEED * tackMultiplier : BOAT_SPEED;
                let currentSpeed = currentSpeedBase;

                // Check Gusts
                let speedMultiplier = 1.0;
                for (const g of gusts) {
                    // Check intersection with ellipse logic or simplified bounding box
                    // Bounding box is okay, but let's be more precise if possible
                    // Or stick to rect for speed, but stacking is key.
                    
                    // Simple collision: check if boat center is inside gust rect
                    if (this.x >= g.x && this.x <= g.x + g.width &&
                        this.y >= g.y && this.y <= g.y + g.height) {
                        
                        // Overlapping gusts stack multiplicatively
                        speedMultiplier *= g.strength;
                    }
                }
                
                // Cap max boost to 1.3x
                if (speedMultiplier > 1.3) speedMultiplier = 1.3;
                
                currentSpeed *= speedMultiplier;

                this.x += Math.sin(this.heading) * currentSpeed;
                this.y -= Math.cos(this.heading) * currentSpeed;

                // Update Trail
                // Calculate Stern Position (Back of boat)
                // Boat Center is (x,y). Heading 0 is Up.
                // Stern is 'down' in local space (0, radius).
                // Rotated: 
                // sternX = x - sin(h) * r
                // sternY = y + cos(h) * r
                // Wait, sin(0)=0, cos(0)=1. sternY = y + r. Correct (below center).
                const sternX = this.x - Math.sin(this.heading) * this.radius;
                const sternY = this.y + Math.cos(this.heading) * this.radius;

                // Only add point if we've moved enough distance
                let addPoint = false;
                if (this.trail.length === 0) {
                    addPoint = true;
                } else {
                    const lastPos = this.trail[this.trail.length - 1];
                    const dist = Math.hypot(sternX - lastPos.x, sternY - lastPos.y);
                    if (dist > 2) addPoint = true; // High resolution for smooth trails
                }
                
                if (addPoint) {
                    this.trail.push({
                        x: sternX, 
                        y: sternY, 
                        heading: this.heading,
                        life: 1.0 // Start at full opacity
                    });
                }
                
                // Decay trail
                for (let i = this.trail.length - 1; i >= 0; i--) {
                    const p = this.trail[i];
                    p.life -= 0.008; // Slower fade (approx 2 seconds)
                    if (p.life <= 0) {
                        this.trail.splice(i, 1);
                    }
                }

                // Update Luff Timer
                this.luffTimer += 0.5; // Controls speed of flap

                // Manage Hail Timer & Logic
                if (this.hailTimer > 0) this.hailTimer--;
                this.updateHailingLogic();

                // Collision with walls (User & AI)
                const poly = this.getPolygon();
                let hitWall = false;
                for (const p of poly) {
                    if (p.x < 0 || p.x > width) {
                        hitWall = true;
                        break;
                    }
                }

                if (hitWall) {
                    if (this.isUser) {
                        // User DNF
                        gameState = 'finished';
                        medalEl.style.display = 'flex';
                        medalRank.innerText = "DNF";
                        medalMsg.innerText = "You hit a wall!";
                        medalEl.style.backgroundColor = '#ff4444'; // Red for crash
                        sfx.playStartGun(); 
                        return;
                    } else {
                        // AI DSQ
                        dsqBoat(this, "Hit the wall");
                    }
                }
                
                if (this.isUser) {
                    // User Auto-Hail Logic
                    // Check if approaching wall and blocked
                    const margin = 50;
                    if ((this.x < margin && this.tack === -1) || (this.x > width - margin && this.tack === 1)) {
                        const blocker = this.findTackBlocker();
                        if (blocker) {
                             this.initiateHail(blocker);
                        }
                    }
                }

                // AI Tacking Logic
                if (!this.isUser && difficulty !== 'will') {
                    const margin = 50;
                    const criticalMargin = 20;
                    
                    let urgentTack = false;
                    let isCritical = false;

                    // 1. Boundary Avoidance (High Priority)
                    // Use this.tack to determine intent, not current heading.
                    if (this.x < margin && this.tack === -1) urgentTack = true;
                    else if (this.x > width - margin && this.tack === 1) urgentTack = true;
                    
                    if (this.x < criticalMargin && this.tack === -1) isCritical = true;
                    else if (this.x > width - criticalMargin && this.tack === 1) isCritical = true;

                    // 2. Collision Avoidance (Port vs Starboard)
                    // If on Port Tack (1), yield to Starboard Tack (-1)
                    if (!urgentTack && this.tack === 1) {
                         // Safety Check: If we are close to the Left Wall (margin), 
                         // tacking to Starboard (-1) would put us into the wall.
                         if (this.x < margin) {
                             // Skip avoidance
                         } else {
                             const avoidanceRange = this.radius * 2.5; 
                             
                             for (const other of boats) {
                                 if (other === this || other.finished || other.dsq) continue;
                                 if (other.hailedBy === this) continue;
                                 
                                 if (other.tack === -1) { 
                                     if (other.x > this.x) { 
                                         const dx = other.x - this.x;
                                         const dy = Math.abs(other.y - this.y);
                                         if (dx < avoidanceRange && dy < avoidanceRange) {
                                             urgentTack = true;
                                             // If very close, force tack (Critical)
                                             if (dx < this.radius * 1.5 && dy < this.radius * 1.5) {
                                                 isCritical = true;
                                             }
                                             break;
                                         }
                                     }
                                 }
                             }
                         }
                    }
                    
                    if (urgentTack) {
                        // Check for blockers before tacking!
                        const blocker = this.findTackBlocker();
                        if (blocker) {
                            if (isCritical) {
                                // Desperate tack! We hailed them, they didn't move.
                                // OR collision imminent.
                                // Tack anyway. If we hit them, they are DSQ (Rule 20).
                                this.tackBoat(true);
                            } else {
                                this.initiateHail(blocker);
                            }
                        } else {
                            this.tackBoat();
                        }
                    }
                    // 3. Strategic Tacking (Wind Shifts)
                    else {
                        // Difficulty Logic
                        const windThreshold = 5 * Math.PI / 180;
                        let reactionChance = 0.005;
                        let useWindStrategy = true;

                        switch(difficulty) {
                            case 'matty':
                                useWindStrategy = false; // Random tacking
                                reactionChance = 0.002;
                                break;
                            case 'louis':
                                useWindStrategy = false; // Random tacking
                                reactionChance = 0.004; // Slightly more active
                                break;
                            case 'monkey':
                                useWindStrategy = true;
                                reactionChance = 0.005; // Slow reaction
                                break;
                            case 'oisin':
                                useWindStrategy = true;
                                reactionChance = 0.01;
                                break;
                            case 'max':
                                useWindStrategy = true;
                                reactionChance = 0.02;
                                break;
                            case 'russell':
                                useWindStrategy = true;
                                reactionChance = 0.05; // Fast reaction
                                break;
                        }

                        if (!useWindStrategy) {
                            // Random tacking completely ignoring wind strategy
                            if (Math.random() < reactionChance) {
                                // Check blocker first!
                                if (!this.findTackBlocker()) {
                                    this.tackBoat();
                                }
                            }
                        } else {
                            // Strategic Tacking based on Wind
                            if (windDirection < -windThreshold && this.tack === -1) {
                                 // Wind from left, currently heading Left. Should tack to Right.
                                 if (Math.random() < reactionChance) {
                                     // Check blocker first!
                                     if (!this.findTackBlocker()) this.tackBoat();
                                 }
                            } else if (windDirection > windThreshold && this.tack === 1) {
                                 // Wind from right, currently heading Right. Should tack to Left.
                                 if (Math.random() < reactionChance) {
                                     // Check blocker first!
                                     if (!this.findTackBlocker()) this.tackBoat();
                                 }
                            }
                        }
                    }
                }

                // Bounce off sides instead of wrapping? Or just let them sail off?
                // User didn't specify, but "no infinite loop" suggests linear course.
                // We'll let them sail off screen horizontally but keep them updated.
                
                // Check finish line
                // Check if any vertex of the boat crosses the finish line
                const finishPoly = this.getPolygon();
                let finished = false;
                for (const p of finishPoly) {
                    if (p.y <= FINISH_LINE_Y) {
                        finished = true;
                        break;
                    }
                }

                if (finished) {
                    this.finished = true;
                    finishedBoatsCount++;
                    
                    if (this.isUser) {
                        let rank = finishedBoatsCount;
                        let suffix = 'th';
                        if (rank === 1) suffix = 'st';
                        else if (rank === 2) suffix = 'nd';
                        else if (rank === 3) suffix = 'rd';
                        endGame(rank, suffix);
                    }
                }
            }

            draw(ctx) {
                // Draw Wake (V-Shape from stern)
                if (this.trail.length > 1) {
                    ctx.save();
                    ctx.lineJoin = 'round';
                    ctx.lineCap = 'round';
                    
                    const baseHalfWidth = this.radius * 0.5; // Start width at stern
                    
                    // Iterate and draw segments
                    // We draw segment i to i+1
                    for (let i = 0; i < this.trail.length - 1; i++) {
                        const p1 = this.trail[i];
                        const p2 = this.trail[i+1];
                        
                        // Calculate width based on life (older = wider)
                        // Life goes 1.0 (new) -> 0.0 (old)
                        // Age factor 0.0 -> 1.0
                        const ageFactor1 = 1.0 - p1.life;
                        const ageFactor2 = 1.0 - p2.life;
                        
                        // Reduce expansion width to keep it closer to boat path (20px max expansion)
                        const width1 = baseHalfWidth + (ageFactor1 * 5); 
                        const width2 = baseHalfWidth + (ageFactor2 * 5);
                        
                        // Perpendicular vectors
                        const perpAngle1 = p1.heading + Math.PI / 2;
                        const dx1 = Math.sin(perpAngle1);
                        const dy1 = -Math.cos(perpAngle1);
                        
                        const perpAngle2 = p2.heading + Math.PI / 2;
                        const dx2 = Math.sin(perpAngle2);
                        const dy2 = -Math.cos(perpAngle2);
                        
                        // Left Side Segment
                        const lx1 = p1.x - dx1 * width1;
                        const ly1 = p1.y - dy1 * width1;
                        const lx2 = p2.x - dx2 * width2;
                        const ly2 = p2.y - dy2 * width2;
                        
                        // Right Side Segment
                        const rx1 = p1.x + dx1 * width1;
                        const ry1 = p1.y + dy1 * width1;
                        const rx2 = p2.x + dx2 * width2;
                        const ry2 = p2.y + dy2 * width2;
                        
                        // Draw Segment
                        // Use average life for opacity? Or p1 life?
                        // p1 is older in the array index sense if we push new ones to end?
                        // Wait, I push to end. So index 0 is oldest.
                        // My update loop says trail.push().
                        // So index 0 is the tail end (fading out). Index length-1 is near boat.
                        // p1 (index i) is older than p2 (index i+1).
                        
                        ctx.beginPath();
                        ctx.moveTo(lx1, ly1);
                        ctx.lineTo(lx2, ly2);
                        ctx.strokeStyle = `rgba(255, 255, 255, ${p1.life * 0.4})`; // Fade out
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(rx1, ry1);
                        ctx.lineTo(rx2, ry2);
                        ctx.strokeStyle = `rgba(255, 255, 255, ${p1.life * 0.4})`;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                }

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.heading);

                // Draw Hull
                ctx.fillStyle = this.isUser ? COLOR_USER : COLOR_OPPONENT;
                ctx.beginPath();
                ctx.moveTo(0, -this.radius); // Bow
                ctx.lineTo(this.radius * 0.7, this.radius); // Rear Right
                ctx.lineTo(0, this.radius * 0.8); // Center Rear
                ctx.lineTo(-this.radius * 0.7, this.radius); // Rear Left
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw Sail
                ctx.fillStyle = 'white';
                
                // Luffing Logic
                // Luff if pointing near wind (heading approx 0 relative to wind) OR if tacking logic is active
                // Heading is absolute. Wind is absolute (windDirection).
                // "Directly into wind" means heading is close to windDirection.
                const angleToWind = Math.abs(this.heading - windDirection);
                // Also check if heading + 2PI is close to wind if we had wrapping, but here wind is 0.
                // Normalize angle diff to -PI to PI if needed, but here simple diff usually works since values are small.
                const luffingThreshold = 20 * Math.PI / 180;
                // isTacking is local var in update(), need to infer it or just use angle.
                // Actually, if we are turning (target != heading), we are likely tacking.
                const isTurning = Math.abs(this.heading - this.targetHeading) > 0.01;
                const isIntoWind = angleToWind < luffingThreshold;
                
                let boomEndX = 0;
                let boomEndY = this.radius * 0.5;
                
                const boomSide = this.tack > 0 ? -1 : 1; // Default boom side
                
                if (isIntoWind || isTurning) {
                    // Flapping / Luffing
                    // Rapidly oscillate the boom tip or sail shape
                    // We'll just wiggle the end point X
                    const wiggle = Math.sin(this.luffTimer) * 5;
                    boomEndX = wiggle; 
                    // Sail looks like it's centered but shaking
                } else {
                    // Full Sail
                    // Boom direction depends on wind direction relative to boat heading
                    const angleRelativeToWind = this.heading - windDirection;
                    const currentBoomSide = angleRelativeToWind > 0 ? 1 : -1;
                    boomEndX = currentBoomSide * this.radius * 0.8;
                }

                ctx.beginPath();
                ctx.moveTo(0, -this.radius * 0.5); // Mast base
                ctx.lineTo(0, this.radius * 0.5); // Mast top (or vice versa in this drawing logic)
                ctx.lineTo(boomEndX, boomEndY); // Boom end
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                if (this.dsq) {
                    ctx.save();
                    ctx.translate(0, this.radius * 0.8);
                    // Point left (-90) if boat leans right, point right (+90) if boat leans left
                    ctx.rotate(this.heading > 0 ? -Math.PI/2 : Math.PI/2);
                    drawSmallRedFlag(ctx, 0, 0);
                    ctx.restore();
                }

                // Draw Hailing Bubble
                if (this.hailingTarget) {
                    ctx.save();
                    // Keep text upright
                    ctx.rotate(-this.heading);
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 4;
                    ctx.fillText("Room!", 0, -this.radius * 1.5);
                    ctx.shadowBlur = 0;
                    ctx.restore();
                }
                
                // Draw Warning if Hailed (for User)
                if (this.isUser && this.hailedBy) {
                    ctx.save();
                    ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform to draw absolute
                    ctx.fillStyle = '#ff4444';
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.font = 'bold 24px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 4;
                    ctx.fillText("TACK NOW!", width/2, height/2 - 50);
                    ctx.strokeText("TACK NOW!", width/2, height/2 - 50);
                    ctx.restore();
                }

                ctx.restore();
            }

            tackBoat(force = false) {
                if (this.finished) return false;
                // Prevent double tacking if turn is not complete, unless forced (e.g. by Rule 20)
                if (!force && Math.abs(this.heading - this.targetHeading) > 0.01) return false;

                this.tack *= -1;
                this.lastTackTime = Date.now();
                this.updateTargetHeading();
                
                this.hailedBy = null; // Clear liability on tack

                if (this.isUser) {
                    sfx.playTackSound();
                }
                return true;
            }
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }

        function init() {
            resize();
            window.addEventListener('resize', resize);
            resetGame();
            requestAnimationFrame(gameLoop);

            // Open Settings immediately
            optSpeed.value = BOAT_SPEED;
            optBoats.value = boatCount;
            optDiff.value = difficulty;
            optSound.checked = soundEnabled;
            updateSettingsUI();
            settingsModal.style.display = 'block';
        }

        function resetGame() {
            boats.length = 0;
            gusts.length = 0;
            
            // Init Ripples if empty
            if (ripples.length === 0) {
                for(let i=0; i<RIPPLE_COUNT; i++) ripples.push(new Ripple());
            }
            // Init Confetti if empty
            if (confettiParticles.length === 0) {
                for(let i=0; i<CONFETTI_COUNT; i++) confettiParticles.push(new Confetti());
            } else {
                // Reset active state
                confettiParticles.forEach(c => c.active = false);
            }

            const startY = height - 50; // Start at bottom
            
            // Distribute boats
            const userIndex = Math.floor(boatCount / 2);
            
            // Available width for boats (keep margins)
            const margin = Math.min(width * 0.1, 50);
            const availableWidth = width - (2 * margin);
            // If only 1 boat (shouldn't happen with min 2), center it.
            // If > 1, spacing = width / (count - 1)
            const step = boatCount > 1 ? availableWidth / (boatCount - 1) : 0;

            // Reset Wind
            windDirection = 0;
            windTarget = 0;
            
            finishedBoatsCount = 0;

            for (let i = 0; i < boatCount; i++) {
                const x = boatCount > 1 ? margin + (i * step) : width / 2;
                boats.push(new Boat(x, startY, i === userIndex));
            }

            gameState = 'waiting';
            uiInstructions.innerText = "Tap to Start Sequence";
            medalEl.style.display = 'none'; // Hide medal
            blackFlagMsg.style.display = 'none'; // Hide BF
            
            // Show Eunice message if Will mode
            // BUT only after start. Wait for GO.
            redFlagMsg.style.display = 'none';
        }

        function endGame(rank, suffix) {
            gameState = 'finished';
            uiInstructions.innerText = ""; // Clear bottom text
            redFlagMsg.style.display = 'none'; // Hide Eunice
            
            // Show Medal
            medalEl.style.display = 'flex';
            medalRank.innerText = `${rank}${suffix}`;
            
            let color = '#CD7F32'; // Bronze default
            if (rank === 1) color = '#FFD700'; // Gold
            else if (rank === 2) color = '#C0C0C0'; // Silver
            
            // Handle DNF specially
            if (rank === "DNF") {
                medalRank.innerText = "DNF";
                color = '#ff4444';
            }
            
            medalEl.style.backgroundColor = color;
            
            // Special message for 1st place
            if (rank === 1) {
                // Capitalize difficulty name
                const diffName = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
                let winMsg = `Congrats! You beat ${diffName}!`;
                if (difficulty === 'matty') {
                    winMsg += "\nWant a medal bro?";
                }
                medalMsg.innerText = winMsg;
                
                // Explode Confetti
                confettiParticles.forEach(c => c.explode());
            } 
            else if (rank === "DNF") {
                 // Already handled by wall collision msg setting, but ensure safety
            }
            else {
                medalMsg.innerText = "Unlucky pal, stick to college work";
            }
        }

        function isClearAstern(behind, ahead) {
            // Transform 'behind' position into 'ahead' local space (aligned with heading)
            // Project vector (behind - ahead) onto ahead's heading vector
            // Heading 0 is Up (0, -1). Vector is (sin(h), -cos(h))
            // We want projection onto BACKWARD vector (Stern direction).
            // Backward vector is opposite of heading? 
            // Heading is forward. Stern is at +radius along "Back" axis?
            // Wait, draw() says: moveTo(0, -radius) [Bow], lineTo(0, radius) [Stern].
            // So in Local Draw Space: Y+ is Back.
            // Heading angle rotates this space.
            // So Stern vector direction is essentially same as Heading vector reversed?
            // Actually, Canvas rotate(h) rotates +Y axis to Heading angle? No.
            // Canvas coord system: +Y is Down.
            // Heading 0: Rotation 0. Boat drawn upright. Bow at -r (Up), Stern at +r (Down).
            // So if Heading is 0, Stern points Down (+Y).
            // So Stern Vector is (sin(h), -cos(h)) rotated 180?
            // Actually, simpler:
            // "Forward" unit vector: dx = sin(h), dy = -cos(h).
            // Project (B - A) onto Forward vector.
            // distFwd = (bx-ax)*sin(h) + (by-ay)*(-cos(h))
            // Stern is at distFwd = -radius.
            // "Behind stern line" means distFwd < -radius.
            
            const dx = behind.x - ahead.x;
            const dy = behind.y - ahead.y;
            const fwdX = Math.sin(ahead.heading);
            const fwdY = -Math.cos(ahead.heading);
            
            const distFwd = dx * fwdX + dy * fwdY;
            
            return distFwd < -ahead.radius;
        }

        function drawSmallRedFlag(ctx, x, y) {
            ctx.save();
            ctx.translate(x, y);
            ctx.fillStyle = '#ff4444';
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            
            // Flag pole
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -20);
            ctx.stroke();
            
            // Flag
            ctx.beginPath();
            ctx.moveTo(0, -20);
            ctx.lineTo(12, -15);
            ctx.lineTo(0, -10);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            ctx.restore();
        }

        function dsqBoat(boat, reason = "You were on Port! Starboard has right of way.") {
            if (boat.dsq || boat.finished) return;
            
            if (boat.isUser) {
                gameState = 'finished';
                medalEl.style.display = 'flex';
                medalRank.innerText = "DSQ";
                medalMsg.innerText = reason;
                medalEl.style.backgroundColor = '#ff4444'; 
                sfx.playStartGun();
            } else {
                boat.dsq = true;
                boat.moving = false;
            }
        }

        function polygonsIntersect(a, b) {
            const polygons = [a, b];
            for (let i = 0; i < polygons.length; i++) {
                const polygon = polygons[i];
                for (let j = 0; j < polygon.length; j++) {
                    const p1 = polygon[j];
                    const p2 = polygon[(j + 1) % polygon.length];
                    
                    const normal = { x: p2.y - p1.y, y: p1.x - p2.x };
                    
                    let minA = Infinity, maxA = -Infinity;
                    for (const p of a) {
                        const projected = normal.x * p.x + normal.y * p.y;
                        if (projected < minA) minA = projected;
                        if (projected > maxA) maxA = projected;
                    }
                    
                    let minB = Infinity, maxB = -Infinity;
                    for (const p of b) {
                        const projected = normal.x * p.x + normal.y * p.y;
                        if (projected < minB) minB = projected;
                        if (projected > maxB) maxB = projected;
                    }
                    
                    if (maxA < minB || maxB < minA) return false;
                }
            }
            return true;
        }

        function checkCollisions() {
            // Check every pair
            for (let i = 0; i < boats.length; i++) {
                for (let j = i + 1; j < boats.length; j++) {
                    const b1 = boats[i];
                    const b2 = boats[j];
                    
                    if (b1.finished || b1.dsq || b2.finished || b2.dsq) continue;
                    
                    const dx = b1.x - b2.x;
                    const dy = b1.y - b2.y;
                    const dist = Math.hypot(dx, dy);
                    
                    // Collision radius sum check (Broad Phase)
                    // Use 1.5 multiplier to ensure we catch corners of the triangle
                    if (dist < (b1.radius + b2.radius) * 1.5) {
                        // Narrow Phase: Polygon Intersection
                        const poly1 = b1.getPolygon();
                        const poly2 = b2.getPolygon();
                        
                        if (polygonsIntersect(poly1, poly2)) {
                            // Collision! Check Rules.
                            
                            // Rule 20: Room to Tack at Obstruction (Highest Priority)
                            // Check if b1 and b2 are part of a hailing chain.
                            // Case A: b1 is upstream of b2 (b1 -> ... -> b2). b2 (and downstream) is liable.
                            // Case B: b2 is upstream of b1 (b2 -> ... -> b1). b1 (and downstream) is liable.
                            
                            let upstreamBoat = null;
                            
                            // Check b1 -> b2 (Is b1 hailing b2 directly or indirectly?)
                            let curr = b1;
                            let loopGuard = 0;
                            while (curr.hailingTarget && loopGuard < 20) {
                                if (curr.hailingTarget === b2) {
                                    upstreamBoat = b1; 
                                    break;
                                }
                                curr = curr.hailingTarget;
                                loopGuard++;
                                if (curr === b1) break; 
                            }
                            
                            if (!upstreamBoat) {
                                // Check b2 -> b1
                                curr = b2;
                                loopGuard = 0;
                                while (curr.hailingTarget && loopGuard < 20) {
                                    if (curr.hailingTarget === b1) {
                                        upstreamBoat = b2;
                                        break;
                                    }
                                    curr = curr.hailingTarget;
                                    loopGuard++;
                                    if (curr === b2) break;
                                }
                            }
                            
                            if (upstreamBoat) {
                                // We found a chain relationship.
                                // The boat downstream (and the ultimate end of that chain) is liable.
                                // Trace from upstreamBoat to the very end of the chain.
                                
                                let chainEnd = upstreamBoat;
                                const visited = [];
                                while (chainEnd.hailingTarget) {
                                    if (visited.includes(chainEnd)) break;
                                    visited.push(chainEnd);
                                    chainEnd = chainEnd.hailingTarget;
                                }
                                
                                dsqBoat(chainEnd, "Failed to give room to tack! (Rule 20 Chain)");
                            }
                            
                            // Rule 13: While Tacking
                            else {
                                const b1Tacking = b1.isTackingRule();
                        const b2Tacking = b2.isTackingRule();
                        
                        if (b1Tacking || b2Tacking) {
                            if (b1Tacking && b2Tacking) {
                                // Both tacking: One on the left is in the wrong
                                if (b1.x < b2.x) dsqBoat(b1, "You were on the left while both tacking.");
                                else dsqBoat(b2, "You were on the left while both tacking.");
                            } else if (b1Tacking) {
                                // b1 is tacking -> b1 keeps clear
                                dsqBoat(b1, "You tacked too close! (Rule 13)");
                            } else {
                                // b2 is tacking -> b2 keeps clear
                                dsqBoat(b2, "You tacked too close! (Rule 13)");
                            }
                        }
                        // Case 1: Opposite Tacks (Rule 10)
                        else if (b1.tack !== b2.tack) {
                            // Starboard (-1) vs Port (1)
                            if (b1.tack === -1 && b2.tack === 1) {
                                dsqBoat(b2, "You were on Port! Starboard has right of way."); 
                            } else if (b1.tack === 1 && b2.tack === -1) {
                                dsqBoat(b1, "You were on Port! Starboard has right of way."); 
                            }
                        } 
                        // Case 2: Same Tack
                        else {
                            // Check Clear Astern
                            // Is b1 Clear Astern of b2?
                            if (isClearAstern(b1, b2)) {
                                dsqBoat(b1, "You hit them from behind! (Clear Astern)");
                            }
                            // Is b2 Clear Astern of b1?
                            else if (isClearAstern(b2, b1)) {
                                dsqBoat(b2, "You hit them from behind! (Clear Astern)");
                            }
                            // Overlap -> Windward keeps clear
                            else {
                                // Rotate positions to align with wind (Wind from Top = 0)
                                // Wind Direction 0 means wind comes from Top (0, -1 vector?) No, Arrow points Down.
                                // Code uses windDirection as rotation.
                                // If we rotate by -windDirection, wind is from Top (North).
                                
                                const x1 = b1.x * Math.cos(-windDirection) - b1.y * Math.sin(-windDirection);
                                const x2 = b2.x * Math.cos(-windDirection) - b2.y * Math.sin(-windDirection);
                                
                                // Starboard Tack (-1): Wind from Right. Windward is Max X.
                                if (b1.tack === -1) {
                                    if (x1 > x2) dsqBoat(b1, "You were Windward! (Rule 11)");
                                    else dsqBoat(b2, "You were Windward! (Rule 11)");
                                }
                                // Port Tack (1): Wind from Left. Windward is Min X.
                                else {
                                    if (x1 < x2) dsqBoat(b1, "You were Windward! (Rule 11)");
                                    else dsqBoat(b2, "You were Windward! (Rule 11)");
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    }

        function drawWindArrow(ctx) {
            // Draw a big arrow at the top center indicating wind from top
            const x = width / 2; // Center horizontally
            const y = 60; // Slightly down from top
            const arrowLen = 40;
            
            ctx.save();
            ctx.translate(x, y);
            
            // Rotate based on windDirection.
            // windDirection 0 is From Top (arrow points down).
            // +windDirection means wind coming from East of North? 
            // In canvas, y is down. Math.sin(heading) moves +x (right).
            // Our boats move with heading 0 as UP. Wait.
            // Boat: dy = -cos(heading). dx = sin(heading). 
            // Heading 0 -> dy=-1 (Up), dx=0. So heading 0 is North.
            // Boat tack is +/- 40 deg.
            // If wind is 0 (North), boat heads +/- 40.
            
            // If wind shifts +10 deg (from NNE), it comes from slightly right.
            // Boat on starboard (+tack) must head +10 + 40 = +50.
            // Boat on port (-tack) must head +10 - 40 = -30.
            // This matches our formula: target = wind + tack*40.
            
            // Visualizing the Arrow:
            // Arrow points DOWN (with the wind).
            // If windDirection is 0, arrow points DOWN (PI).
            // If windDirection is +10 deg, wind blows towards South-West?
            // Wait. Wind direction usually means "FROM".
            // If wind is FROM 10 degrees (NNE), it blows TOWARDS 190 degrees (SSW).
            // So arrow rotation should be PI + windDirection.
            ctx.rotate(windDirection);

            // Wind is FROM top (North), so arrow points DOWN (South)
            // But usually "Wind Direction" arrows point into the wind?
            // "Wind from Top" -> Wind blows DOWN.
            // Let's draw an arrow pointing DOWN to show airflow direction.
            
            ctx.strokeStyle = 'white';
            ctx.fillStyle = 'white';
            ctx.lineWidth = 3;
            
            ctx.beginPath();
            ctx.moveTo(0, -arrowLen/2);
            ctx.lineTo(0, arrowLen/2);
            ctx.stroke();

            // Arrowhead at bottom
            ctx.beginPath();
            ctx.moveTo(0, arrowLen/2);
            ctx.lineTo(-10, arrowLen/2 - 10);
            ctx.lineTo(10, arrowLen/2 - 10);
            ctx.closePath();
            ctx.fill();

            // Text should remain upright-ish or rotate with arrow? 
            // Let's keep "WIND" label relative to arrow or fixed.
            // If we rotate context, text rotates. 
            // Let's draw text before rotation or untranslate.
            ctx.restore();
            
            // Draw text separately to keep it horizontal
            ctx.save();
            ctx.translate(x, y);
            ctx.fillStyle = 'white';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText("WIND", 0, -arrowLen/2 - 15);
            ctx.restore();
        }

        function drawStartLine(ctx) {
            // Only draw during starting phase
            if (gameState !== 'starting' && gameState !== 'waiting') return;
            
            // Draw a line near bottom where boats should stay behind
            const lineY = height - 100; // 50px above startY usually
            
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 4;
            ctx.setLineDash([10, 10]); 
            ctx.beginPath();
            ctx.moveTo(0, lineY);
            ctx.lineTo(width, lineY);
            ctx.stroke();
            ctx.setLineDash([]); 

            ctx.fillStyle = '#ffff00';
            ctx.textAlign = 'right';
            ctx.font = 'bold 16px sans-serif';
            ctx.fillText("START LINE", width - 20, lineY - 10);
        }

        function drawFinishLine(ctx) {
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 4;
            ctx.setLineDash([20, 20]); // Dashed line
            ctx.beginPath();
            ctx.moveTo(0, FINISH_LINE_Y);
            ctx.lineTo(width, FINISH_LINE_Y);
            ctx.stroke();
            ctx.setLineDash([]); // Reset

            // Label
            ctx.fillStyle = '#ff4444';
            ctx.textAlign = 'right';
            ctx.font = 'bold 20px sans-serif';
            ctx.fillText("FINISH", width - 20, FINISH_LINE_Y - 10);
        }

        function gameLoop() {
            ctx.clearRect(0, 0, width, height);

            // Draw Background Elements
            // Ripples first
            ripples.forEach(r => {
                r.update();
                r.draw(ctx);
            });
            
            drawFinishLine(ctx);
            // drawStartLine(ctx); // Removed
            drawWindArrow(ctx);

            // Wind Shift Logic
            if (gameState === 'playing' || gameState === 'starting') {
                // Smoothly interpolate windDirection to windTarget
                if (windDirection !== windTarget) {
                    const diff = windTarget - windDirection;
                    if (Math.abs(diff) < 0.005) {
                        windDirection = windTarget;
                    } else {
                        windDirection += diff * 0.05; // Ease to target
                    }
                }

                // Randomly pick new target
                if (Math.random() < WIND_SHIFT_CHANCE) {
                    const shift = (Math.random() - 0.5) * 2 * MAX_SHIFT;
                    // Bias towards center: The further out, the stronger the pull back
                    const centeringBias = -windTarget * 0.5;
                    
                    let newTarget = windTarget + shift + centeringBias;
                    // Clamp
                    if (newTarget > MAX_WIND_DEVIATION) newTarget = MAX_WIND_DEVIATION;
                    if (newTarget < -MAX_WIND_DEVIATION) newTarget = -MAX_WIND_DEVIATION;
                    windTarget = newTarget;
                }
            }
            
            // Audio: Modulate wind volume based on gusts/speed
            // Check if user is inside a gust
            let windVol = 0.05;
            const userBoat = boats.find(b => b.isUser);
            if (userBoat) {
                for (const g of gusts) {
                    if (g.active && 
                        userBoat.x >= g.x && userBoat.x <= g.x + g.width &&
                        userBoat.y >= g.y && userBoat.y <= g.y + g.height) {
                        windVol = 0.15; // Louder in gust
                        break;
                    }
                }
            }
            sfx.setWindVolume(windVol);

            // Gust Logic & Rendering (Draw under boats)
            if (gameState === 'playing' || gameState === 'race_on' || gameState === 'starting' || gameState === 'waiting') {
                // Spawn
                if (gameState !== 'waiting' && Math.random() < GUST_SPAWN_CHANCE) {
                    gusts.push(new Gust());
                }
                
                // Update & Draw
                for (let i = gusts.length - 1; i >= 0; i--) {
                    const g = gusts[i];
                    if (gameState !== 'waiting') g.update(); // Only move if game is active-ish
                    
                    // Draw active gusts
                    g.draw(ctx);

                    if (!g.active) {
                        gusts.splice(i, 1);
                    }
                }
            }

            // Update Boats only if playing or starting (for AI positioning/user mistakes)
            if (gameState === 'playing' || gameState === 'race_on') {
                boats.forEach(boat => boat.update());
                checkCollisions();
                
                // Check if all boats finished to stop loop logic? 
                // Or just keep running. 
            } else if (gameState === 'starting') {
                // Allow movement but check black flag
                // Actually, boats should stay still until tapped in previous logic. 
                // Now, user taps to start TIMER.
                // During timer, if user moves across line -> Black Flag.
                // AI should wait for timer.
                
                // Let's change input logic. 
                // Tap to start timer. Boats are frozen? Or can they sail?
                // "User has to tap once timer reaches 0". 
                // This implies user taps at 0 to GO. 
                // If they tap before 0? "if too soon they are told they got a Black Flag"
                // So tapping trigger the start. 
                
                // Revised Flow:
                // 1. Game loads 'waiting'. Tap to Start SEQUENCE.
                // 2. State 'starting'. Timer counts down 5..4..3..2..1..0.
                // 3. During countdown, input is ignored? No, "if too soon... Black Flag".
                // So tapping during countdown = Black Flag.
                // 4. At 0, State 'playing'. AI starts automatically. User must tap to start moving?
                // Or user taps at 0 to launch?
                // Usually sailing games: you sail pre-start.
                // "tap once the timer reaches 0" -> Tap to launch boat.
                
                // So during 'starting', boats are frozen at start line?
                // "if too soon they are told they got a Black Flag" -> Tapping during countdown = lose.
            }

            // Draw Boats
            boats.forEach(boat => boat.draw(ctx));
            
            // Draw Confetti
            confettiParticles.forEach(c => {
                c.update();
                c.draw(ctx);
            });

            requestAnimationFrame(gameLoop);
        }

        /* MOVED UP - Defined above now */
        // const startTimerEl = document.getElementById('start-timer');
        // const blackFlagMsg = document.getElementById('black-flag-msg');

        function startSequence() {
            gameState = 'starting';
            // uiInstructions.innerText = "Wait for 0..."; // Removed instruction, just timer
            uiInstructions.innerText = ""; 
            startTimer = 3;
            startTimerEl.style.display = 'block';
            startTimerEl.innerText = startTimer;
            sfx.playStartBeep(440);
            
            // Clear any existing interval
            if (startInterval) clearInterval(startInterval);
            
            startInterval = setInterval(() => {
                startTimer--;
                if (startTimer > 0) {
                    startTimerEl.innerText = startTimer;
                    sfx.playStartBeep(440 + (3-startTimer)*100); // Pitch up
                } else if (startTimer === 0) {
                    startTimerEl.innerText = "GO!";
                    sfx.playStartGun();
                    gameState = 'race_on'; 
                    launchAI();
                } else {
                    // Timer finished (negative), game is officially playable if not already
                    clearInterval(startInterval);
                    startTimerEl.style.display = 'none';
                }
            }, 1000);
        }

        function launchAI() {
            // Start all AI boats immediately
            boats.forEach(boat => {
                if (!boat.isUser) {
                    boat.moving = true;
                }
            });
        }

        // Add moving flag to boat
        // Update Boat constructor to include moving = false
        // Update Boat.update to return if !this.moving

        function handleInput(e) {
            sfx.init(); // Init audio context on first touch
            
            if (gameState === 'waiting') {
                startSequence();
            } 
            else if (gameState === 'starting') {
                // User tapped during countdown!
                if (startTimer > 0) {
                    clearInterval(startInterval);
                    startTimerEl.style.display = 'none';
                    gameState = 'finished';
                    blackFlagMsg.style.display = 'block';
                    uiInstructions.innerText = "Tap to Restart";
                    // Fail state
                } else {
                    // Timer is 0 or race_on (though race_on usually handled by interval finish)
                    // If timer is 0 (GO displayed), valid start
                    // State becomes playing
                    gameState = 'playing';
                    uiInstructions.innerText = "Tap to Tack";
                    startTimerEl.style.display = 'none';
                    
                    // Find user boat and enable it
                    const userBoat = boats.find(b => b.isUser);
                    if (userBoat) {
                        userBoat.moving = true;
                    }
                    
                    // Also trigger AI if they haven't started (race_on handles it, but just in case)
                    if (startInterval) clearInterval(startInterval);
                    launchAI();
                    
                    // Show Eunice message if Will mode (delayed start)
                    if (difficulty === 'will') {
                        redFlagMsg.style.display = 'block';
                    }
                }
            }
            else if (gameState === 'race_on') {
                 // User tapped after GO disappeared (late start)
                 gameState = 'playing';
                 uiInstructions.innerText = "Tap to Tack";
                 startTimerEl.style.display = 'none'; // Ensure timer is hidden
                 
                 const userBoat = boats.find(b => b.isUser);
                 if (userBoat) {
                     userBoat.moving = true;
                 }
                 
                 if (difficulty === 'will') {
                        redFlagMsg.style.display = 'block';
                 }
            }
            else if (gameState === 'playing') {
                const userBoat = boats.find(b => b.isUser);
                if (userBoat) userBoat.tackBoat();
            } else if (gameState === 'finished') {
                resetGame();
            }
        }

        window.addEventListener('mousedown', handleInput);
        window.addEventListener('touchstart', (e) => {
            // Check if touch target is UI
            if (e.target.closest('#settings-btn') || e.target.closest('#settings-modal')) {
                return;
            }
            e.preventDefault();
            handleInput(e);
        }, { passive: false });

        const medalEl = document.getElementById('medal');
        const medalRank = document.getElementById('medal-rank');
        const medalMsg = document.getElementById('medal-msg');
        const redFlagMsg = document.getElementById('red-flag-msg');
        const settingsBtn = document.getElementById('settings-btn');
        const settingsModal = document.getElementById('settings-modal');
        const saveBtn = document.getElementById('save-btn');
        const optSpeed = document.getElementById('opt-speed');
        const optSpeedVal = document.getElementById('opt-speed-val');
        const optBoats = document.getElementById('opt-boats');
        const optBoatsVal = document.getElementById('opt-boats-val');
        const optDiff = document.getElementById('opt-diff');
        const optSound = document.getElementById('opt-sound');
        const startTimerEl = document.getElementById('start-timer');
        const blackFlagMsg = document.getElementById('black-flag-msg');

        function updateSettingsUI() {
            // optSpeedVal.innerText = parseFloat(optSpeed.value).toFixed(2); // Removed display
            optBoatsVal.innerText = optBoats.value;
        }

        settingsBtn.addEventListener('mousedown', (e) => {
            e.stopPropagation(); // Prevent game input
            // Load current values
            optSpeed.value = BOAT_SPEED;
            optBoats.value = boatCount;
            optDiff.value = difficulty;
            optSound.checked = soundEnabled;
            updateSettingsUI();
            
            settingsModal.style.display = 'block';
        });
        
        // Also handle touch for button specifically if needed, but mousedown often covers it. 
        // Let's add click just in case.
        settingsBtn.addEventListener('click', (e) => {
            e.stopPropagation();
        });

        optSpeed.addEventListener('input', updateSettingsUI);
        optBoats.addEventListener('input', updateSettingsUI);

        saveBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            // Save values
            BOAT_SPEED = parseFloat(optSpeed.value);
            boatCount = parseInt(optBoats.value);
            difficulty = optDiff.value;
            soundEnabled = optSound.checked;

            settingsModal.style.display = 'none';
            resetGame();
        });
        
        // Prevent clicks in modal from triggering game
        settingsModal.addEventListener('mousedown', (e) => e.stopPropagation());
        settingsModal.addEventListener('touchstart', (e) => e.stopPropagation());

        init();
    </script>
</body>
</html>