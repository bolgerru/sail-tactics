<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sail Tactics Game</title>
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0077be; /* Ocean blue */
            font-family: sans-serif;
            color: white;
            user-select: none;
            -webkit-user-select: none;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            font-size: 1.2rem;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
        }
        #settings-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.3);
            color: white;
            border: 1px solid white;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 5px;
            z-index: 100;
        }
        #settings-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 1000; /* Ensure it's on top of everything including red flag (z-150) and medal (z-200) */
            width: 80%;
            max-width: 300px;
        }
        #settings-modal label {
            display: block;
            margin: 10px 0 5px;
        }
        #settings-modal input, #settings-modal select {
            margin-bottom: 10px;
            width: 100%;
            box-sizing: border-box;
        }
        .sound-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 12px 0;
        }
        .sound-row input {
            width: auto;
            margin: 0;
        }
        .sound-row span {
            color: white;
        }
        #medal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border-radius: 50%;
            display: flex; /* Initially none, handled by JS */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            border: 5px solid white;
            z-index: 200;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            pointer-events: auto; /* Allow clicking to restart */
            cursor: pointer;
        }
        #medal h1 { margin: 0; font-size: 3rem; }
        #start-timer {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 8rem;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
            z-index: 120;
            pointer-events: none;
            width: 100%;
            text-align: center;
        }
        #red-flag-msg {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 68, 68, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            border: 3px solid white;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
            z-index: 150;
            pointer-events: none;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        #black-flag-msg {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            border: 3px solid white;
            z-index: 150;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="ui">
        <!-- Wind text removed, will be drawn on canvas -->
    </div>
    <button id="settings-btn">‚öôÔ∏è Settings</button>
    <div id="settings-modal">
        <h2>Settings</h2>
        
        <label>Wind Speed</label>
        <input type="range" id="opt-speed" min="0.05" max="0.2" step="0.01">

        <label>Number of Boats: <span id="opt-boats-val"></span></label>
        <input type="range" id="opt-boats" min="2" max="10" step="1">

        <div id="multiplayer-section" style="border: 1px solid white; padding: 10px; margin: 10px 0; border-radius: 5px;">
            <h3 style="margin: 0 0 10px 0;">Multiplayer (Max 10)</h3>
            <div id="mp-menu">
                <button id="mp-host-btn" style="width: 100%; margin-bottom: 5px;">Host Game</button>
                <div style="display: flex; gap: 5px;">
                    <input type="text" id="mp-join-id" placeholder="Enter Host ID" style="margin: 0;">
                    <button id="mp-join-btn" style="width: auto;">Join</button>
                </div>
            </div>
            <div id="mp-status" style="margin-top: 5px; font-size: 0.9rem; color: #aaa;">Status: Offline</div>
            <div id="mp-id-display" style="display: none; margin-top: 5px; color: yellow; font-weight: bold;"></div>
        </div>

        <div id="advanced-settings" style="display:none; border: 1px dashed yellow; padding: 10px; margin: 10px 0;">
            <h3 style="margin: 0 0 10px 0; color: yellow;">Advanced Override</h3>
            <label>Custom Speed</label>
            <input type="number" id="custom-speed" step="0.01" placeholder="1.5">
            <label>Custom Boat Count</label>
            <input type="number" id="custom-boats" placeholder="3">
            <label>Boat Radius</label>
            <input type="number" id="custom-radius" placeholder="15">
            <label style="display:inline-block; margin-top:10px;">
                <input type="checkbox" id="chaos-mode" style="width:auto; margin:0;"> Chaos Mode
            </label>
            <br>
            <label style="display:inline-block;">
                <input type="checkbox" id="god-mode" style="width:auto; margin:0;"> God Mode (Invincible)
            </label>
        </div>

        <label>Difficulty</label>
        <select id="opt-diff">
            <option value="matty">Matty (Easiest)</option>
            <option value="louis">Louis</option>
            <option value="will">Will</option>
            <option value="monkey">Monkey</option>
            <option value="oisin">Oisin</option>
            <option value="max">Max</option>
            <option value="russell">Russell (Hardest)</option>
        </select>

        <label class="sound-row">
            <input type="checkbox" id="opt-sound" checked>
            <span>Sound</span>
        </label>

        <br>
        <button id="save-btn">Save & Restart</button>
    </div>

    <div id="start-timer"></div>
    
    <div id="black-flag-msg">
        üè¥ BLACK FLAG!
    </div>

    <div id="red-flag-msg">
        üö© Eunice:<br>RED FLAG FOR EVERYONE EXCPEPT YOU!
    </div>

    <div id="medal" style="display: none;">
        <h1 id="medal-rank">1st</h1>
        <p id="medal-msg">Congrats!</p>
        <p style="font-size: 0.8rem; margin-top: 10px;">Tap to Restart</p>
    </div>

    <div id="instructions">Tap to Start</div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiInstructions = document.getElementById('instructions');

        // Game State
        // Logical Width/Height for Game World
        const LOGICAL_WIDTH_MP = 400; // Fixed width for MP
        const LOGICAL_HEIGHT_MP = 800; // Fixed height for MP
        
        // Dynamic variables (set in resize/reset)
        let logicalWidth = 0; 
        let logicalHeight = 0;
        
        let width = 0; // Canvas/Window width
        let height = 0; // Canvas/Window height
        let scale = 1;
        
        const boats = [];
        let BOAT_SPEED = 0.1; // Configurable
        let boatCount = 3; // Configurable
        let difficulty = 'matty'; // Configurable
        let soundEnabled = true;
        let BOAT_RADIUS = 15;
        let GOD_MODE = false;

        const TACK_ANGLE_RAD = 40 * Math.PI / 180;
        
        // Colors
        const COLOR_USER = '#ffcc00'; // Yellow
        const COLOR_OPPONENT = '#cccccc'; // White/Grey
        
        let gameState = 'waiting'; // waiting, starting, playing, finished
        let startTimer = 3;
        let startInterval = null;
        const START_LINE_Y = 600; // Will be set in resetGame
        let finishedBoatsCount = 0;
        const FINISH_LINE_Y = 100;

        const TURN_SPEED = 0.05; // Radians per frame
        
        // Wind Physics
        let windDirection = 0; // 0 is from Top (North)
        let windTarget = 0;
        // Shift chance per frame (60fps). 0.005 is approx every 3.3s
        let WIND_SHIFT_CHANCE = 0.005; 
        const MAX_WIND_DEVIATION = 30 * Math.PI / 180; // Clamp total deviation
        let MAX_SHIFT = 20 * Math.PI / 180; // Max shift per event

        // Gusts
        const gusts = [];
        const ripples = [];
        const confettiParticles = [];
        const RIPPLE_COUNT = 100;
        const CONFETTI_COUNT = 100;

        const GUST_SPAWN_CHANCE = 0.005; // Much less frequent
        const GUST_MOVE_SPEED = 0.3;
        
        // Multiplayer Globals
        let isMultiplayer = false;
        let isHost = false;
        let network = null;
        let mpStatus = 'offline'; // offline, connecting, connected
        const MAX_PLAYERS = 10;

        // Network Manager
        class NetworkManager {
            constructor() {
                this.peer = null;
                this.connections = []; // List of all connections (for Host)
                this.hostConn = null;  // Connection to Host (for Client)
                this.myId = null;
            }

            init(id = null) {
                const peerId = id || Math.random().toString(36).substr(2, 4).toUpperCase();
                
                this.peer = new Peer(peerId);

                this.peer.on('open', (id) => {
                    this.myId = id;
                    updateMpStatus('Connected as: ' + id, 'green');
                    if (isHost) {
                        document.getElementById('mp-id-display').innerText = "ID: " + id;
                        document.getElementById('mp-id-display').style.display = 'block';
                    }
                });

                this.peer.on('connection', (conn) => {
                    // Incoming connection (Host logic)
                    if (this.connections.length >= MAX_PLAYERS - 1) {
                        // Reject if full
                        conn.close();
                        return;
                    }
                    
                    this.setupHostConnection(conn);
                });

                this.peer.on('error', (err) => {
                    console.error(err);
                    updateMpStatus('Error: ' + err.type, 'red');
                });
            }

            connectTo(hostId) {
                if (!this.peer) {
                    this.init(); 
                }
                
                if (this.peer.open) {
                    this._performConnect(hostId);
                } else {
                    this.peer.on('open', () => {
                        this._performConnect(hostId);
                    });
                }
            }

            _performConnect(hostId) {
                if (this.hostConn) return; // Prevent duplicates

                const conn = this.peer.connect(hostId);
                this.hostConn = conn;
                this.setupClientConnection();
                updateMpStatus('Connecting to ' + hostId + '...', 'yellow');
            }

            setupHostConnection(conn) {
                this.connections.push(conn);
                
                conn.on('open', () => {
                    updateMpStatus(`Players: ${this.connections.length + 1}/${MAX_PLAYERS}`, 'lime');
                    
                    // Assign Player ID (Index in array + 1, since Host is 0)
                    // We need a stable ID system. 
                    // Let's use the connection's peer ID or just their index in list?
                    // Index is risky if someone disconnects.
                    // Better to assign a unique boat ID.
                    
                    // Send "Welcome" package with their assigned Boat ID
                    // We'll assign boat ID based on connection order for now.
                    // 0 is Host. 1..9 are Clients.
                    const assignedId = this.connections.indexOf(conn) + 1;
                    
                    conn.send({ 
                        type: 'welcome', 
                        payload: { 
                            id: assignedId,
                            w: LOGICAL_WIDTH_MP, // Sync logical dimensions
                            h: LOGICAL_HEIGHT_MP
                        }
                    });
                    
                    // Reset game if waiting? Or add boat dynamically?
                    // Dynamic add is better for lobby feel.
                    if (gameState === 'waiting') {
                        resetGame();
                    }
                });

                conn.on('data', (data) => {
                    // Identify source by looking up conn in list
                    const clientId = this.connections.indexOf(conn) + 1;
                    this.handleHostData(data, clientId);
                });

                conn.on('close', () => {
                    // Remove from list
                    const index = this.connections.indexOf(conn);
                    if (index > -1) {
                        this.connections.splice(index, 1);
                    }
                    updateMpStatus(`Players: ${this.connections.length + 1}/${MAX_PLAYERS}`, 'lime');
                    
                    // If game waiting, reset to remove boat
                    if (gameState === 'waiting') {
                        resetGame();
                    }
                });
            }

            setupClientConnection() {
                this.hostConn.on('open', () => {
                    updateMpStatus('Connected to Host!', 'lime');
                });

                this.hostConn.on('data', (data) => {
                    this.handleClientData(data);
                });

                this.hostConn.on('close', () => {
                    updateMpStatus('Disconnected', 'red');
                    this.hostConn = null;
                    isMultiplayer = false;
                });
            }

            broadcast(data) {
                this.connections.forEach(conn => {
                    if (conn.open) conn.send(data);
                });
            }

            sendToHost(data) {
                if (this.hostConn && this.hostConn.open) {
                    this.hostConn.send(data);
                }
            }

            handleHostData(data, clientId) {
                if (data.type === 'tack') {
                    // Client controls boat with id = clientId
                    // Find boat with this ID
                    const boat = boats.find(b => b.id === clientId);
                    if (boat && !boat.finished && !boat.dnf) {
                        boat.tackBoat();
                    }
                } else                 if (data.type === 'restart_request') {
                    // Only restart if game is actually finished
                    if (gameState === 'finished') {
                        network.broadcast({ type: 'restart' });
                        resetGame();
                    }
                } else if (data.type === 'start_request') {
                    if (gameState === 'waiting') startSequence();
                }
            }

            handleClientData(data) {
                if (data.type === 'state') {
                    applyWorldState(data.payload);
                } else if (data.type === 'gust_spawn') {
                     gusts.push(new Gust(data.payload));
                } else if (data.type === 'welcome') {
                    // Set my assigned ID
                    myMultiplayerId = data.payload.id;
                    // Also sync dimensions? We hardcoded them, but good to verify.
                } else if (data.type === 'restart') {
                    resetGame(); // Client side reset clears boats
                }
            }
        }
        
        let myMultiplayerId = 0; // 0 for host, 1+ for clients

        function updateMpStatus(msg, color='white') {
            const el = document.getElementById('mp-status');
            el.innerText = msg;
            el.style.color = color;
        }

        // Wind Shadow Constants
        const SHADOW_LENGTH_MULT = 6; // Multiplier of radius (3 boat lengths approx)
        const SHADOW_WIDTH_MULT = 3;  // Multiplier of radius (2 boat widths approx)
        const MAX_SHADOW_PENALTY = 0.2; // 20% speed loss
        
        // Sound Manager
        class SoundManager {
            constructor() {
                this.ctx = null;
                this.windGain = null;
                this.isInit = false;
            }

            init() {
                if (this.isInit) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.isInit = true;
                this.startWindNoise();
            }

            playStartBeep(freq = 440) {
                if (!this.ctx || !soundEnabled) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.5);
            }

            playStartGun() {
                if (!this.ctx || !soundEnabled) return;
                const t = this.ctx.currentTime;
                // Short bright beep ‚Äî one sine, ~0.2s, no ramp
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(660, t);
                gain.gain.setValueAtTime(0.4, t);
                gain.gain.setValueAtTime(0.4, t + 0.15);
                gain.gain.linearRampToValueAtTime(0, t + 0.2);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(t);
                osc.stop(t + 0.2);
            }

            playTackSound() {
                if (!this.ctx || !soundEnabled) return;
                // White noise burst
                const bufferSize = this.ctx.sampleRate * 0.2;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();
                // Filter to make it sound like fabric snapping
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 800;

                gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start();
            }

            playSplashSound() {
                if (!this.ctx || !soundEnabled) return;
                // Similar to tack but softer/longer
                 const bufferSize = this.ctx.sampleRate * 0.5;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 400;

                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.4);
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start();
            }

            startWindNoise() {
                if (!this.ctx) return;
                // Continuous pink noise loop
                const bufferSize = this.ctx.sampleRate * 2;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    data[i] = (lastOut + (0.02 * white)) / 1.02;
                    lastOut = data[i];
                    data[i] *= 3.5; 
                }
                // Pink noise approximation logic requires variable persistence, simplified here:
                // Just use brownian-ish noise from above loop (lastOut)
                
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                noise.loop = true;
                
                this.windGain = this.ctx.createGain();
                this.windGain.gain.value = 0.05; // Base volume
                
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 400;

                noise.connect(filter);
                filter.connect(this.windGain);
                this.windGain.connect(this.ctx.destination);
                noise.start();
            }

            setWindVolume(vol) {
                if (this.windGain) {
                    const v = soundEnabled ? vol : 0;
                    this.windGain.gain.setTargetAtTime(v, this.ctx.currentTime, 0.1);
                }
            }
        }
        let lastOut = 0; // For noise generation
        const sfx = new SoundManager();

        class Ripple {
            constructor() {
                this.init();
            }
            
            init() {
                this.x = Math.random() * logicalWidth;
                this.y = Math.random() * logicalHeight;
                this.life = Math.random(); // 0 to 1
                this.speed = Math.random() * 0.5 + 0.5;
            }

            update() {
                // Move with windDirection
                this.x -= Math.sin(windDirection) * this.speed * 2;
                this.y += Math.cos(windDirection) * this.speed * 2;
                
                this.life -= 0.005;
                if (this.life <= 0 || this.x < -50 || this.x > logicalWidth + 50 || this.y < -50 || this.y > logicalHeight + 50) {
                    this.init();
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(windDirection); // Rotate to match flow
                
                ctx.strokeStyle = `rgba(255, 255, 255, ${this.life * 0.2})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, -5);
                ctx.lineTo(0, 5);
                ctx.stroke();
                
                ctx.restore();
            }
        }
        
        class Confetti {
            constructor() {
                this.reset(true);
            }
            
            reset(startWait = false) {
                this.x = logicalWidth / 2;
                this.y = logicalHeight / 2;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 5;
                this.vx = Math.sin(angle) * speed;
                this.vy = Math.cos(angle) * speed;
                this.gravity = 0.2;
                this.friction = 0.98;
                this.life = Math.random() * 100 + 100;
                this.color = `hsl(${Math.random() * 360}, 100%, 50%)`;
                this.rotation = Math.random() * 360;
                this.rotationSpeed = (Math.random() - 0.5) * 10;
                this.active = false;
                if (!startWait) this.active = true;
            }
            
            explode() {
                this.reset(false);
            }
            
            update() {
                if (!this.active) return;
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.vx *= this.friction;
                this.vy *= this.friction;
                this.rotation += this.rotationSpeed;
                this.life--;
                if (this.life <= 0) this.active = false;
            }
            
            draw(ctx) {
                if (!this.active) return;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation * Math.PI / 180);
                ctx.fillStyle = this.color;
                ctx.fillRect(-4, -4, 8, 8);
                ctx.restore();
            }
        }

        class Gust {
            constructor(data = null) {
                if (data) {
                    this.width = data.w;
                    this.height = data.h;
                    this.x = data.x;
                    this.y = data.y;
                    this.strength = data.s;
                    this.active = true;
                } else {
                    // Make size proportional to screen size
                    // Width: 25% to 40% of screen width
                    const minW = logicalWidth * 0.25;
                    const varW = logicalWidth * 0.15;
                    this.width = Math.random() * varW + minW;
                    
                    // Height: 20% to 40% of screen height
                    const minH = logicalHeight * 0.2;
                    const varH = logicalHeight * 0.2;
                    this.height = Math.random() * varH + minH;
    
                    this.x = Math.random() * (logicalWidth - this.width);
                    this.y = -this.height; // Start above screen
                    this.strength = Math.random() * 0.2 + 1.1; // Reduced: 1.1x to 1.3x speed boost
                    this.active = true;
                }
            }

            update() {
                this.y += GUST_MOVE_SPEED;
                if (this.y > logicalHeight) {
                    this.active = false;
                }
            }

            draw(ctx) {
                ctx.save();
                
                // Radial gradient for soft edges all around
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                
                // Use a radial gradient scaled to match the ellipse aspect ratio
                // Since createRadialGradient is circular, we'll scale the context
                ctx.translate(centerX, centerY);
                ctx.scale(1, this.height / this.width); // Scale Y to make circle an ellipse
                
                // Use strength to determine opacity
                // Strength ranges 1.2 to 1.6
                // Map to opacity 0.2 to 0.5
                const baseOpacity = 0.2 + (this.strength - 1.2) * 0.75;
                const edgeOpacity = baseOpacity * 0.75;

                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width / 2);
                gradient.addColorStop(0, `rgba(0, 30, 80, ${baseOpacity})`); // Center darker based on strength
                gradient.addColorStop(0.6, `rgba(0, 30, 80, ${edgeOpacity})`); 
                gradient.addColorStop(1, "rgba(0, 30, 80, 0)"); // Fade to transparent

                
                ctx.fillStyle = gradient;
                
                ctx.beginPath();
                ctx.arc(0, 0, this.width / 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }

        class Boat {
            constructor(x, y, isUser = false, id = null) {
                this.x = x;
                this.y = y;
                this.isUser = isUser; // Locally true if controlled by this player
                this.id = id; // 0 for Host, 1 for Client
                this.tack = 1; // 1 or -1
                this.updateTargetHeading();
                this.heading = this.targetHeading; 
                this.radius = BOAT_RADIUS;
                this.finished = false;
                this.dnf = false; // New: Did Not Finish (Crashed)
                this.spinDir = Math.random() < 0.5 ? 1 : -1; // For Will mode
                this.moving = false; // Waiting for start
                this.trail = []; // Wake trail
                this.luffTimer = 0; // For sail animation
                this.dsq = false; // Disqualified flag
                this.lastTackTime = 0;
                this.hailingTarget = null;
                this.hailedBy = null;
                this.hailTimer = 0;
                this.finishRank = 0; // Rank when finished
            }

            findTackBlocker() {
                // Determine intended direction
                // If tack is 1 (Rightward), next tack is -1 (Leftward). We are turning Left.
                // We check for boats on the side we are turning towards.
                // Tack 1 -> turning Left (look for boats on Left)
                // Tack -1 -> turning Right (look for boats on Right)
                
                const intendedTack = this.tack * -1;
                const lookLeft = intendedTack === -1; // Turning Left
                
                // Rotate to Wind Space
                // Wind Direction 0 = From Top.
                // Rotate by -windDirection to align Y with Wind (inverted?). 
                // Let's just project onto Cross-Wind Axis and Wind Axis.
                // Wind Vector is (sin(w), -cos(w))? No, arrow points down.
                // Let's rely on standard rotation.
                // Rotate -windDirection.
                // If wind is 0, no rotation. Y is down. X is right.
                // Boat heading 0 is Up (-Y). 
                // Wind from Top (0). Boats sail Up. 
                // "Horizontal" means X-axis. "Vertical" means Y-axis.
                
                const cos = Math.cos(-windDirection);
                const sin = Math.sin(-windDirection);
                
                const myRx = this.x * cos - this.y * sin;
                const myRy = this.x * sin + this.y * cos;
                
                let closest = null;
                let minDist = Infinity;
                
                // Search parameters
                const rangeX = this.radius * 2.5; // Reduced from 4 (closer hailing)
                const rangeY = this.radius * 2; // Strict abeam check
                
                for (const other of boats) {
                    if (other === this || other.finished || other.dsq) continue;
                    
                    const otherRx = other.x * cos - other.y * sin;
                    const otherRy = other.x * sin + other.y * cos;
                    
                    const dx = otherRx - myRx;
                    const dy = Math.abs(otherRy - myRy);
                    
                    // Check Vertical alignment (Abeam)
                    if (dy > rangeY) continue;
                    
                    // Check Horizontal Side and Distance
                    let isBlocked = false;
                    if (lookLeft) {
                        // Look for boat on Left (dx < 0)
                        if (dx < 0 && dx > -rangeX) isBlocked = true;
                    } else {
                        // Look for boat on Right (dx > 0)
                        if (dx > 0 && dx < rangeX) isBlocked = true;
                    }
                    
                    if (isBlocked) {
                        const d = Math.abs(dx);
                        if (d < minDist) {
                            minDist = d;
                            closest = other;
                        }
                    }
                }
                return closest;
            }

            initiateHail(target) {
                if (!target || this.hailingTarget === target) return;
                
                this.hailingTarget = target;
                this.hailingTargetOriginalTack = target.tack; // Track if they moved
                target.hailedBy = this;
                target.hailTimer = 60; // Force reaction for ~1 sec
                
                // If user is target, we might show UI elsewhere
            }

            updateHailingLogic() {
                // 1. Am I hailing someone?
                if (this.hailingTarget) {
                    const target = this.hailingTarget;
                    // Has target tacked away?
                    const stillBlocking = this.findTackBlocker();
                    
                    let shouldClear = false;
                    if (stillBlocking !== target) {
                        shouldClear = true;
                        
                        // BUT: If target hasn't tacked yet, and we are still close, keep the link!
                        // This handles the "forced tack into crash" scenario where we tack but they didn't move.
                        if (target.tack === this.hailingTargetOriginalTack) {
                            const dist = Math.hypot(target.x - this.x, target.y - this.y);
                            if (dist < this.radius * 6) { // Still in proximity
                                shouldClear = false;
                            }
                        }
                    }

                    if (shouldClear) {
                        // Clear!
                        this.hailingTarget = null;
                        if (target) target.hailedBy = null; // Clear their flag
                        
                        if (!this.isUser) {
                            this.tackBoat(true); // Finally tack!
                        }
                    }
                }
                
                // 2. Am I being hailed?
                if (this.hailedBy) {
                    // I must tack soon.
                    // But wait, can I tack?
                    const myBlocker = this.findTackBlocker();
                    
                    if (myBlocker) {
                        // I am blocked too! Chain the hail.
                        this.initiateHail(myBlocker);
                    } else {
                        // I am free to tack.
                        if (!this.isUser) {
                            // AI: Force tack immediately (Rule 20 compliance)
                            this.tackBoat(true);
                        }
                        // User: Do nothing (wait for manual input).
                        // "TACK NOW!" is displayed in draw().
                    }
                }
            }

            isTackingRule() {
                return (Date.now() - this.lastTackTime) < 1000;
            }

            getPolygon() {
                // Vertices relative to center (0,0)
                // Bow: (0, -radius)
                // Rear Right: (0.7 * radius, radius)
                // Rear Left: (-0.7 * radius, radius)
                
                const pts = [
                    {x: 0, y: -this.radius},
                    {x: this.radius * 0.7, y: this.radius},
                    {x: -this.radius * 0.7, y: this.radius}
                ];

                const cos = Math.cos(this.heading);
                const sin = Math.sin(this.heading);

                return pts.map(p => {
                    // Rotate
                    const rx = p.x * cos - p.y * sin;
                    const ry = p.x * sin + p.y * cos;
                    // Translate
                    return {
                        x: this.x + rx,
                        y: this.y + ry
                    };
                });
            }

            calculateShadowPenalty(allBoats) {
                let totalPenalty = 0;
                
                const shadowLen = this.radius * SHADOW_LENGTH_MULT;
                const shadowWid = this.radius * SHADOW_WIDTH_MULT;
                
                const windVx = Math.sin(windDirection);
                const windVy = -Math.cos(windDirection); // Down is +Y in rotation if 0, but vector is (0,1) for downwind?
                // Wait. WindDirection 0 means wind comes from Top. Blows Down.
                // Vector (0, 1). 
                // sin(0)=0. -cos(0)=-1. This would be (0, -1) [Up].
                // So Wind Vector (Flow Direction) is (sin(w), cos(w))?
                // If w=0, vector=(0,1) [Down]. Correct.
                
                // Stern Vector: Opposite to heading.
                // Heading 0 = Up (0, -1). Stern = Down (0, 1).
                // Heading vector: (sin(h), -cos(h)).
                // Stern vector: (-sin(h), cos(h)).
                
                // But shadow direction needs to be calculated per boat that casts it!
                // Wait, this method is called on the boat RECEIVING the penalty ("this").
                // We iterate over "other" boats (the blockers).
                // So we need the Shadow Vector of "other".
                
                for (const other of allBoats) {
                    if (other === this || other.finished || other.dsq) continue;

                    // Calculate Other Boat's Shadow Vector
                    const wVx = Math.sin(windDirection); // Wind Flow (0 -> 0,1) NO. 
                    // windDirection 0 (North) -> Blows South (0,1).
                    // sin(0)=0. cos(0)=1. So vector is (sin(w), cos(w))?
                    // if w=PI/2 (East wind, blows West). sin(PI/2)=1. cos=0. Vector (1,0) [Right].
                    // But East wind blows TO West (-1, 0).
                    // So Wind Flow Vector is (-sin(w), cos(w))?
                    // Let's stick to using rotation logic which was robust in previous step.
                    // Previous step: x' = dx * cos(-w) + dy * sin(-w).
                    // This rotated everything so Wind came from Top (Vector 0,-1 in rotated space? or 0,1?)
                    
                    // Let's just compute the Average Angle.
                    // Wind Angle (Flow): windDirection + PI (since windDir is where it comes FROM).
                    // Actually windDirection 0 is "North". Wind FROM North blows South (PI).
                    const windFlowAngle = windDirection + Math.PI;
                    
                    // Stern Angle: heading + PI.
                    const sternAngle = other.heading + Math.PI;
                    
                    // Blend Vector
                    // Wind Vector
                    const wvX = Math.sin(windFlowAngle);
                    const wvY = -Math.cos(windFlowAngle);
                    
                    // Stern Vector
                    const svX = Math.sin(sternAngle);
                    const svY = -Math.cos(sternAngle);
                    
                    // Average
                    let shadowVx = wvX + svX;
                    let shadowVy = wvY + svY;
                    
                    // Normalize (not strictly needed for atan2 but good practice)
                    const mag = Math.hypot(shadowVx, shadowVy);
                    if (mag > 0.001) {
                         shadowVx /= mag;
                         shadowVy /= mag;
                    }
                    
                    const shadowAngle = Math.atan2(shadowVx, -shadowVy); // Convert back to bearing-ish
                    
                // But wait, atan2(x, -y) matches the canvas rotation logic where 0 is Up?
                // canvas rotation: 0 = Up. +PI/2 = Right.
                // standard atan2(y,x): 0 = Right.
                // Let's trust the vector math. 
                // shadowVx is X component. shadowVy is Y component (Up is -1).
                // Angle = atan2(x, -y) gives 0 for (0, -1), PI for (0, 1).
                
                // Now rotate `this` (target) relative to `other` (source).
                // We want to rotate the coordinate system so that the Shadow Vector aligns with Positive Y.
                // If Shadow Vector is Down (PI), we want 0 rotation (since Y is Down).
                // If Shadow Vector is Right (PI/2), we want -PI/2 rotation (so Y points Right).
                // Formula: Rotation = shadowAngle - PI.
                
                const rotation = shadowAngle - Math.PI;
                const cosS = Math.cos(-rotation);
                const sinS = Math.sin(-rotation);
                
                // Rotate
                const dx = this.x - other.x;
                const dy = this.y - other.y;
                
                const rx = dx * cosS - dy * sinS;
                const ry = dx * sinS + dy * cosS;
                
                // Now check ellipse logic (same as before)
                    // Center of ellipse is at (0, shadowLen/2) in local space
                    // We applied visual offset of -other.radius (shift up/forward).
                    // So Center Y becomes (shadowLen/2) - other.radius.
                    
                    const yOffset = -other.radius;
                    const centY = (shadowLen / 2) + yOffset;
                    const radX = shadowWid / 2;
                    const radY = shadowLen / 2;
                    
                    const distEq = ((rx * rx) / (radX * radX)) + ((ry - centY) * (ry - centY)) / (radY * radY);
                    
                    if (distEq <= 1) {
                        // Inside Shadow
                        // Penalty based on distance from START of shadow (which is at yOffset).
                        // Dist along axis = ry - yOffset.
                        let distAlong = ry - yOffset;
                        
                        let ratio = distAlong / shadowLen;
                        if (ratio < 0) ratio = 0;
                        if (ratio > 1) ratio = 1;
                        totalPenalty += MAX_SHADOW_PENALTY * (1 - ratio);
                    }
                }
                
                if (totalPenalty > 0.4) totalPenalty = 0.4;
                return totalPenalty;
            }

            updateTargetHeading() {
                // Target is relative to wind direction
                this.targetHeading = windDirection + (this.tack * TACK_ANGLE_RAD);
            }

            update() {
                if (this.finished || !this.moving || this.dsq) return;

                let isTacking = false;

                // Will Mode: Continuous Spin
                if (!this.isUser && difficulty === 'will') {
                    this.heading += this.spinDir * TURN_SPEED;
                    isTacking = true; // Considers turning for speed penalty
                } 
                else {
                    // Normal Logic: Smoothly rotate heading towards targetHeading
                    this.updateTargetHeading(); // Update target based on wind

                    if (this.heading !== this.targetHeading) {
                        isTacking = true;
                        // Handle wrapping logic if we were using 0-360, but here headings are small radians.
                        // Simple difference is fine.
                        const diff = this.targetHeading - this.heading;
                        if (Math.abs(diff) < TURN_SPEED) {
                            this.heading = this.targetHeading;
                            isTacking = false;
                        } else {
                            this.heading += Math.sign(diff) * TURN_SPEED;
                        }
                    }
                }

                // Move boat
                let tackMultiplier = 0.7; // Base speed retention
                
                if (!this.isUser) {
                    // Difficulty-based speed retention during tacks
                    switch(difficulty) {
                        case 'matty': tackMultiplier = 0.6; break;
                        case 'louis': tackMultiplier = 0.7; break;
                        case 'will': tackMultiplier = 0.7; break;
                        case 'monkey': tackMultiplier = 0.8; break;
                        case 'oisin': tackMultiplier = 0.9; break;
                        case 'max': tackMultiplier = 0.95; break;
                        case 'russell': tackMultiplier = 0.98; break;
                    }
                }

                const currentSpeedBase = isTacking ? BOAT_SPEED * tackMultiplier : BOAT_SPEED;
                let currentSpeed = currentSpeedBase;

                // Check Gusts
                let speedMultiplier = 1.0;
                for (const g of gusts) {
                    // Check intersection with ellipse logic or simplified bounding box
                    // Bounding box is okay, but let's be more precise if possible
                    // Or stick to rect for speed, but stacking is key.
                    
                    // Simple collision: check if boat center is inside gust rect
                    if (this.x >= g.x && this.x <= g.x + g.width &&
                        this.y >= g.y && this.y <= g.y + g.height) {
                        
                        // Overlapping gusts stack multiplicatively
                        speedMultiplier *= g.strength;
                    }
                }
                
                // Cap max boost to 1.3x
                if (speedMultiplier > 1.3) speedMultiplier = 1.3;
                
                // Wind Shadow Penalty
                const shadowPenalty = this.calculateShadowPenalty(boats);
                speedMultiplier *= (1.0 - shadowPenalty);

                currentSpeed *= speedMultiplier;

                this.x += Math.sin(this.heading) * currentSpeed;
                this.y -= Math.cos(this.heading) * currentSpeed;

                // Update Trail
                // Calculate Stern Position (Back of boat)
                // Boat Center is (x,y). Heading 0 is Up.
                // Stern is 'down' in local space (0, radius).
                // Rotated: 
                // sternX = x - sin(h) * r
                // sternY = y + cos(h) * r
                // Wait, sin(0)=0, cos(0)=1. sternY = y + r. Correct (below center).
                const sternX = this.x - Math.sin(this.heading) * this.radius;
                const sternY = this.y + Math.cos(this.heading) * this.radius;

                // Only add point if we've moved enough distance
                let addPoint = false;
                if (this.trail.length === 0) {
                    addPoint = true;
                } else {
                    const lastPos = this.trail[this.trail.length - 1];
                    const dist = Math.hypot(sternX - lastPos.x, sternY - lastPos.y);
                    if (dist > 2) addPoint = true; // High resolution for smooth trails
                }
                
                if (addPoint) {
                    this.trail.push({
                        x: sternX, 
                        y: sternY, 
                        heading: this.heading,
                        life: 1.0 // Start at full opacity
                    });
                }
                
                // Decay trail
                for (let i = this.trail.length - 1; i >= 0; i--) {
                    const p = this.trail[i];
                    p.life -= 0.008; // Slower fade (approx 2 seconds)
                    if (p.life <= 0) {
                        this.trail.splice(i, 1);
                    }
                }

                // Update Luff Timer
                this.luffTimer += 0.5; // Controls speed of flap

                // Manage Hail Timer & Logic
                if (this.hailTimer > 0) this.hailTimer--;
                this.updateHailingLogic();

                // Collision with walls (User & AI)
                const poly = this.getPolygon();
                let hitWall = false;
                for (const p of poly) {
                    if (p.x < 0 || p.x > logicalWidth) {
                        hitWall = true;
                        break;
                    }
                }

                if (hitWall) {
                    if (this.isUser) {
                        if (GOD_MODE) {
                            // Bounce or just stop? Let's just stop movement component or do nothing (slide along)
                            // If invincible, maybe we just slide. But the logic below is for DNF.
                            // To allow sliding, we'd need to clamp position.
                            // For now, let's just NOT trigger DNF.
                            // But position will go out of bounds?
                            // Let's bounce them back in slightly.
                            if (this.x < 0) this.x = 1;
                            if (this.x > logicalWidth) this.x = logicalWidth - 1;
                        } else {
                            // User DNF
                            // Don't stop game immediately!
                            this.dnf = true;
                            this.moving = false; // Stop boat
                            
                            // Show Medal Locally
                            medalEl.style.display = 'flex';
                            medalRank.innerText = "DNF";
                            medalMsg.innerText = "You hit a wall!";
                            
                            // Update text if MP
                            if (isMultiplayer) {
                                medalMsg.innerText += "\nWaiting for others...";
                            }
                            
                            medalEl.style.backgroundColor = '#ff4444'; // Red for crash
                            sfx.playStartGun(); 
                            
                            if (!isMultiplayer) {
                                gameState = 'finished';
                            } else {
                                // Check if race over (Host side logic handles this in loop)
                            }
                            
                            return;
                        }
                    } else {
                        // AI DSQ
                        dsqBoat(this, "Hit the wall");
                    }
                }
                
                if (this.isUser) {
                    // User Auto-Hail Logic
                    // Check if approaching wall and blocked
                    const margin = 50;
                    if ((this.x < margin && this.tack === -1) || (this.x > logicalWidth - margin && this.tack === 1)) {
                        const blocker = this.findTackBlocker();
                        if (blocker) {
                             this.initiateHail(blocker);
                        }
                    }
                }

                // AI Tacking Logic
                if (!this.isUser && difficulty !== 'will' && !isMultiplayer) {
                    const margin = 50;
                    const criticalMargin = 20;
                    
                    let urgentTack = false;
                    let isCritical = false;

                    // 1. Boundary Avoidance (High Priority)
                    // Use this.tack to determine intent, not current heading.
                    if (this.x < margin && this.tack === -1) urgentTack = true;
                    else if (this.x > logicalWidth - margin && this.tack === 1) urgentTack = true;
                    
                    if (this.x < criticalMargin && this.tack === -1) isCritical = true;
                    else if (this.x > logicalWidth - criticalMargin && this.tack === 1) isCritical = true;

                    // 2. Collision Avoidance (Port vs Starboard)
                    // If on Port Tack (1), yield to Starboard Tack (-1)
                    if (!urgentTack && this.tack === 1) {
                         // Safety Check: If we are close to the Left Wall (margin), 
                         // tacking to Starboard (-1) would put us into the wall.
                         if (this.x < margin) {
                             // Skip avoidance
                         } else {
                             const avoidanceRange = this.radius * 2.5; 
                             
                             for (const other of boats) {
                                 if (other === this || other.finished || other.dsq) continue;
                                 if (other.hailedBy === this) continue;
                                 
                                 if (other.tack === -1) { 
                                     if (other.x > this.x) { 
                                         const dx = other.x - this.x;
                                         const dy = Math.abs(other.y - this.y);
                                         if (dx < avoidanceRange && dy < avoidanceRange) {
                                             urgentTack = true;
                                             // If very close, force tack (Critical)
                                             if (dx < this.radius * 1.5 && dy < this.radius * 1.5) {
                                                 isCritical = true;
                                             }
                                             break;
                                         }
                                     }
                                 }
                             }
                         }
                    }
                    
                    if (urgentTack) {
                        // Check for blockers before tacking!
                        const blocker = this.findTackBlocker();
                        if (blocker) {
                            if (isCritical) {
                                // Desperate tack! We hailed them, they didn't move.
                                // OR collision imminent.
                                // Tack anyway. If we hit them, they are DSQ (Rule 20).
                                this.tackBoat(true);
                            } else {
                                this.initiateHail(blocker);
                            }
                        } else {
                            this.tackBoat();
                        }
                    }
                    // 3. Strategic Tacking (Wind Shifts)
                    else {
                        // Difficulty Logic
                        const windThreshold = 5 * Math.PI / 180;
                        let reactionChance = 0.005;
                        let useWindStrategy = true;

                        switch(difficulty) {
                            case 'matty':
                                useWindStrategy = false; // Random tacking
                                reactionChance = 0.002;
                                break;
                            case 'louis':
                                useWindStrategy = false; // Random tacking
                                reactionChance = 0.004; // Slightly more active
                                break;
                            case 'monkey':
                                useWindStrategy = true;
                                reactionChance = 0.005; // Slow reaction
                                break;
                            case 'oisin':
                                useWindStrategy = true;
                                reactionChance = 0.01;
                                break;
                            case 'max':
                                useWindStrategy = true;
                                reactionChance = 0.02;
                                break;
                            case 'russell':
                                useWindStrategy = true;
                                reactionChance = 0.05; // Fast reaction
                                break;
                        }

                        if (!useWindStrategy) {
                            // Random tacking completely ignoring wind strategy
                            if (Math.random() < reactionChance) {
                                // Check if tacking hits wall
                                const futureTack = this.tack * -1;
                                if ((this.x < margin && futureTack === -1) || (this.x > logicalWidth - margin && futureTack === 1)) {
                                    // Unsafe
                                } else {
                                    // Check blocker first!
                                    if (!this.findTackBlocker()) {
                                        this.tackBoat();
                                    }
                                }
                            }
                        } else {
                            // Strategic Tacking based on Wind
                            if (windDirection < -windThreshold && this.tack === -1) {
                                 // Wind from left, currently heading Left. Should tack to Right.
                                 if (Math.random() < reactionChance) {
                                     const futureTack = 1; // Right
                                     if (this.x > logicalWidth - margin) { /* Unsafe */ } 
                                     else if (!this.findTackBlocker()) this.tackBoat();
                                 }
                            } else if (windDirection > windThreshold && this.tack === 1) {
                                 // Wind from right, currently heading Right. Should tack to Left.
                                 if (Math.random() < reactionChance) {
                                     const futureTack = -1; // Left
                                     if (this.x < margin) { /* Unsafe */ }
                                     else if (!this.findTackBlocker()) this.tackBoat();
                                 }
                            }
                        }
                    }
                }

                // Bounce off sides instead of wrapping? Or just let them sail off?
                // User didn't specify, but "no infinite loop" suggests linear course.
                // We'll let them sail off screen horizontally but keep them updated.
                
                // Check finish line
                // Check if any vertex of the boat crosses the finish line
                const finishPoly = this.getPolygon();
                let finished = false;
                for (const p of finishPoly) {
                    if (p.y <= FINISH_LINE_Y) {
                        finished = true;
                        break;
                    }
                }

                if (finished) {
                    this.finished = true;
                    finishedBoatsCount++;
                    this.finishRank = finishedBoatsCount;
                    
                    if (this.isUser) {
                        let rank = this.finishRank;
                        let suffix = 'th';
                        if (rank === 1) suffix = 'st';
                        else if (rank === 2) suffix = 'nd';
                        else if (rank === 3) suffix = 'rd';
                        endGame(rank, suffix);
                    }
                }
            }

            draw(ctx) {
                // Draw Wind Shadow (Debug/Visual)
                
                // Calculate Shadow Angle for Drawing
                // Wind Flow Angle
                const windFlowAngle = windDirection + Math.PI;
                // Stern Angle
                const sternAngle = this.heading + Math.PI;
                
                // Vectors
                // Standard canvas angle 0 is Up (0,-1). 
                // x = sin(a), y = -cos(a)
                const wvX = Math.sin(windFlowAngle);
                const wvY = -Math.cos(windFlowAngle);
                
                const svX = Math.sin(sternAngle);
                const svY = -Math.cos(sternAngle);
                
                let sVx = wvX + svX;
                let sVy = wvY + svY;
                
                 const mag = Math.hypot(sVx, sVy);
                if (mag > 0.001) {
                     sVx /= mag;
                     sVy /= mag;
                }
                const shadowAngle = Math.atan2(sVx, -sVy);

                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Rotation = shadowAngle - PI to align Y+ with Vector
                ctx.rotate(shadowAngle - Math.PI); 
                
                const sLen = this.radius * SHADOW_LENGTH_MULT;
                const sWid = this.radius * SHADOW_WIDTH_MULT;
                
                // Draw Ellipse extending downwind
                // Center at (0, sLen/2)
                
                // Offset start position to be slightly forward on the boat (e.g. at the mast/bow)
                // In local space (before rotation), boat center is 0,0. Bow is (0, -radius).
                // We want shadow to start near bow?
                // Actually, current implementation centers ellipse at (0, sLen/2).
                // This means the "top" of the ellipse is at (0, 0) -> Boat Center.
                // To move it "forward" (towards bow/upwind relative to shadow flow), we shift the center NEGATIVE Y in rotated space.
                // Shadow flows +Y. So shifting center -Y moves start point up.
                // Let's shift it by -radius (to start at bow).
                
                const yOffset = -this.radius; 
                
                ctx.beginPath();
                ctx.ellipse(0, (sLen/2) + yOffset, sWid/2, sLen/2, 0, 0, Math.PI * 2);
                
                // Gradient for visual feedback
                // Gradient should also shift
                const grd = ctx.createLinearGradient(0, yOffset, 0, sLen + yOffset);
                grd.addColorStop(0, "rgba(0, 0, 0, 0)"); // Fully transparent (Invisible)
                grd.addColorStop(1, "rgba(0, 0, 0, 0)");   // Fully transparent
                
                ctx.fillStyle = grd;
                ctx.fill();
                ctx.restore();

                // Draw Wake (V-Shape from stern)
                if (this.trail.length > 1) {
                    ctx.save();
                    ctx.lineJoin = 'round';
                    ctx.lineCap = 'round';
                    
                    const baseHalfWidth = this.radius * 0.5; // Start width at stern
                    
                    // Iterate and draw segments
                    // We draw segment i to i+1
                    for (let i = 0; i < this.trail.length - 1; i++) {
                        const p1 = this.trail[i];
                        const p2 = this.trail[i+1];
                        
                        // Calculate width based on life (older = wider)
                        // Life goes 1.0 (new) -> 0.0 (old)
                        // Age factor 0.0 -> 1.0
                        const ageFactor1 = 1.0 - p1.life;
                        const ageFactor2 = 1.0 - p2.life;
                        
                        // Reduce expansion width to keep it closer to boat path (20px max expansion)
                        const width1 = baseHalfWidth + (ageFactor1 * 5); 
                        const width2 = baseHalfWidth + (ageFactor2 * 5);
                        
                        // Perpendicular vectors
                        const perpAngle1 = p1.heading + Math.PI / 2;
                        const dx1 = Math.sin(perpAngle1);
                        const dy1 = -Math.cos(perpAngle1);
                        
                        const perpAngle2 = p2.heading + Math.PI / 2;
                        const dx2 = Math.sin(perpAngle2);
                        const dy2 = -Math.cos(perpAngle2);
                        
                        // Left Side Segment
                        const lx1 = p1.x - dx1 * width1;
                        const ly1 = p1.y - dy1 * width1;
                        const lx2 = p2.x - dx2 * width2;
                        const ly2 = p2.y - dy2 * width2;
                        
                        // Right Side Segment
                        const rx1 = p1.x + dx1 * width1;
                        const ry1 = p1.y + dy1 * width1;
                        const rx2 = p2.x + dx2 * width2;
                        const ry2 = p2.y + dy2 * width2;
                        
                        // Draw Segment
                        // Use average life for opacity? Or p1 life?
                        // p1 is older in the array index sense if we push new ones to end?
                        // Wait, I push to end. So index 0 is oldest.
                        // My update loop says trail.push().
                        // So index 0 is the tail end (fading out). Index length-1 is near boat.
                        // p1 (index i) is older than p2 (index i+1).
                        
                        ctx.beginPath();
                        ctx.moveTo(lx1, ly1);
                        ctx.lineTo(lx2, ly2);
                        ctx.strokeStyle = `rgba(255, 255, 255, ${p1.life * 0.4})`; // Fade out
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(rx1, ry1);
                        ctx.lineTo(rx2, ry2);
                        ctx.strokeStyle = `rgba(255, 255, 255, ${p1.life * 0.4})`;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                }

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.heading);

                // Draw Hull
                ctx.fillStyle = this.isUser ? COLOR_USER : COLOR_OPPONENT;
                ctx.beginPath();
                ctx.moveTo(0, -this.radius); // Bow
                ctx.lineTo(this.radius * 0.7, this.radius); // Rear Right
                ctx.lineTo(0, this.radius * 0.8); // Center Rear
                ctx.lineTo(-this.radius * 0.7, this.radius); // Rear Left
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw Sail
                ctx.fillStyle = 'white';
                
                // Luffing Logic
                // Luff if pointing near wind (heading approx 0 relative to wind) OR if tacking logic is active
                // Heading is absolute. Wind is absolute (windDirection).
                // "Directly into wind" means heading is close to windDirection.
                const angleToWind = Math.abs(this.heading - windDirection);
                // Also check if heading + 2PI is close to wind if we had wrapping, but here wind is 0.
                // Normalize angle diff to -PI to PI if needed, but here simple diff usually works since values are small.
                const luffingThreshold = 20 * Math.PI / 180;
                // isTacking is local var in update(), need to infer it or just use angle.
                // Actually, if we are turning (target != heading), we are likely tacking.
                const isTurning = Math.abs(this.heading - this.targetHeading) > 0.01;
                const isIntoWind = angleToWind < luffingThreshold;
                
                let boomEndX = 0;
                let boomEndY = this.radius * 0.5;
                
                const boomSide = this.tack > 0 ? -1 : 1; // Default boom side
                
                if (isIntoWind || isTurning) {
                    // Flapping / Luffing
                    // Rapidly oscillate the boom tip or sail shape
                    // We'll just wiggle the end point X
                    const wiggle = Math.sin(this.luffTimer) * 5;
                    boomEndX = wiggle; 
                    // Sail looks like it's centered but shaking
                } else {
                    // Full Sail
                    // Boom direction depends on wind direction relative to boat heading
                    const angleRelativeToWind = this.heading - windDirection;
                    const currentBoomSide = angleRelativeToWind > 0 ? 1 : -1;
                    boomEndX = currentBoomSide * this.radius * 0.8;
                }

                ctx.beginPath();
                ctx.moveTo(0, -this.radius * 0.5); // Mast base
                ctx.lineTo(0, this.radius * 0.5); // Mast top (or vice versa in this drawing logic)
                ctx.lineTo(boomEndX, boomEndY); // Boom end
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                if (this.dsq) {
                    ctx.save();
                    ctx.translate(0, this.radius * 0.8);
                    // Point left (-90) if boat leans right, point right (+90) if boat leans left
                    ctx.rotate(this.heading > 0 ? -Math.PI/2 : Math.PI/2);
                    drawSmallRedFlag(ctx, 0, 0);
                    ctx.restore();
                }

                // Update Luff Timer (Always update for visuals, even if paused)
                this.luffTimer += 0.5;

                // Draw Hailing Bubble
                if (this.hailingTarget) {
                    ctx.save();
                    // Keep text upright
                    ctx.rotate(-this.heading);
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 4;
                    ctx.fillText("Room!", 0, -this.radius * 1.5);
                    ctx.shadowBlur = 0;
                    ctx.restore();
                }
                
                // Draw Warning if Hailed (for User)
                if (this.isUser && this.hailedBy) {
                    ctx.save();
                    
                    if (isMultiplayer) {
                        // Reset transform logic relative to MP scaling
                        // Actually easier: just draw in local coordinates (rotated/translated boat space)
                        // But text needs to be upright.
                        
                        // We are in boat space (translated, rotated).
                        // To draw screen-aligned text centered on boat:
                        // Rotate back by -this.heading
                        ctx.rotate(-this.heading);
                        // Draw above boat
                    } else {
                        // Dynamic Map (old logic using absolute coords)
                        ctx.setTransform(1, 0, 0, 1, 0, 0); 
                    }
                    
                    if (isMultiplayer) {
                        // Drawing in local space (upright)
                        ctx.fillStyle = '#ff4444';
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2 / scale; // Scale line width back
                        ctx.font = `bold ${24/scale}px sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.shadowColor = 'black';
                        ctx.shadowBlur = 4;
                        // Draw "TACK NOW" slightly above/below boat
                        ctx.fillText("TACK NOW!", 0, -this.radius * 3);
                        ctx.strokeText("TACK NOW!", 0, -this.radius * 3);
                    } else {
                        // Old Absolute Logic
                        ctx.fillStyle = '#ff4444';
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.font = 'bold 24px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.shadowColor = 'black';
                        ctx.shadowBlur = 4;
                        ctx.fillText("TACK NOW!", width/2, height/2 - 50);
                        ctx.strokeText("TACK NOW!", width/2, height/2 - 50);
                    }
                    
                    ctx.restore();
                }

                ctx.restore();
            }

            tackBoat(force = false) {
                if (this.finished) return false;
                // Prevent double tacking if turn is not complete, unless forced (e.g. by Rule 20)
                if (!force && Math.abs(this.heading - this.targetHeading) > 0.01) return false;

                this.tack *= -1;
                this.lastTackTime = Date.now();
                this.updateTargetHeading();
                
                this.hailedBy = null; // Clear liability on tack

                if (this.isUser) {
                    sfx.playTackSound();
                }
                return true;
            }
        }

        function resize() {
            // Screen Dimensions
            const winW = window.innerWidth;
            const winH = window.innerHeight;
            
            width = winW;
            height = winH;
            canvas.width = winW;
            canvas.height = winH;

            if (isMultiplayer) {
                // Fixed Aspect Ratio / Resolution for fairness
                logicalWidth = LOGICAL_WIDTH_MP;
                logicalHeight = LOGICAL_HEIGHT_MP;
                
                const scaleX = winW / logicalWidth;
                const scaleY = winH / logicalHeight;
                // On mobile: fill screen (cover) so the box is bigger and uses more of the display
                const isMobile = Math.min(winW, winH) <= 768;
                scale = isMobile ? Math.max(scaleX, scaleY) : Math.min(scaleX, scaleY);
            } else {
                // Dynamic Map (Full Screen)
                logicalWidth = winW;
                logicalHeight = winH;
                scale = 1;
            }
        }

        function init() {
            resize();
            window.addEventListener('resize', resize);
            resetGame();
            requestAnimationFrame(gameLoop);

            // Open Settings immediately
            optSpeed.value = BOAT_SPEED;
            optBoats.value = boatCount;
            optDiff.value = difficulty;
            optSound.checked = soundEnabled;
            updateSettingsUI();
            settingsModal.style.display = 'block';
        }

        function resetGame() {
            if (isMultiplayer && isHost && network) {
                 network.broadcast({ type: 'restart' });
            }

            boats.length = 0;
            gusts.length = 0;
            
            // Init Ripples if empty
            if (ripples.length === 0) {
                for(let i=0; i<RIPPLE_COUNT; i++) ripples.push(new Ripple());
            }
            // Init Confetti if empty
            if (confettiParticles.length === 0) {
                for(let i=0; i<CONFETTI_COUNT; i++) confettiParticles.push(new Confetti());
            } else {
                // Reset active state
                confettiParticles.forEach(c => c.active = false);
            }

            const startY = logicalHeight - 50; // Start at bottom
            
            // Distribute boats
            // const userIndex = Math.floor(boatCount / 2); // Unused in MP usually, but useful for single player
            
            // Available width for boats (keep margins)
            const margin = Math.min(logicalWidth * 0.1, 50);
            const availableWidth = logicalWidth - (2 * margin);
            // If only 1 boat (shouldn't happen with min 2), center it.
            // If > 1, spacing = width / (count - 1)
            // const step = boatCount > 1 ? availableWidth / (boatCount - 1) : 0; // Recalc below

            // Reset Wind
            windDirection = 0;
            windTarget = 0;
            
            finishedBoatsCount = 0;

            if (isMultiplayer) {
                // Multiplayer Setup: Up to MAX_PLAYERS
                // Host is Boat 0. Connected Clients are Boat 1..N
                // Determine total players
                const totalPlayers = (network && isHost) ? network.connections.length + 1 : 
                                     (network && !isHost) ? 0 : 2; // Client doesn't spawn initially, waits for state?
                
                // Actually, Client should wait for state to spawn boats.
                // Host spawns all boats.
                
                if (isHost) {
                    boatCount = totalPlayers;
                    // Distribute across line
                    const step = boatCount > 1 ? availableWidth / (boatCount - 1) : 0;
                    
                    for(let i=0; i<boatCount; i++) {
                        const x = boatCount > 1 ? margin + (i * step) : logicalWidth / 2;
                        // Boat ID matches player index
                        boats.push(new Boat(x, startY, (i === 0), i));
                    }
                } else {
                    // Client: Don't spawn anything yet. Wait for 'state' packet.
                    // Or spawn placeholders?
                    // 'state' packet will arrive and `applyWorldState` will create/update boats.
                    // But `applyWorldState` currently expects boats to exist to update them.
                    // We need to upgrade `applyWorldState` to create boats if missing.
                }
                
            } else {
                // Single Player
                const userIndex = Math.floor(boatCount / 2);
                const step = boatCount > 1 ? availableWidth / (boatCount - 1) : 0;
                for (let i = 0; i < boatCount; i++) {
                    const x = boatCount > 1 ? margin + (i * step) : logicalWidth / 2;
                    boats.push(new Boat(x, startY, i === userIndex));
                }
            }

            gameState = 'waiting';
            
            if (isMultiplayer && !isHost) {
                 uiInstructions.innerText = "Waiting for Host to Start...";
            } else {
                 uiInstructions.innerText = "Tap to Start Sequence";
            }

            medalEl.style.display = 'none'; // Hide medal
            blackFlagMsg.style.display = 'none'; // Hide BF
            
            // Show Eunice message if Will mode
            // BUT only after start. Wait for GO.
            redFlagMsg.style.display = 'none';
        }

        function endGame(rank, suffix) {
            // Check if game should end
            if (!isMultiplayer) {
                gameState = 'finished';
            }
            
            uiInstructions.innerText = ""; // Clear bottom text
            redFlagMsg.style.display = 'none'; // Hide Eunice
            
            // Show Medal
            medalEl.style.display = 'flex';
            medalRank.innerText = `${rank}${suffix}`;
            
            let color = '#CD7F32'; // Bronze default
            if (rank === 1) color = '#FFD700'; // Gold
            else if (rank === 2) color = '#C0C0C0'; // Silver
            
            // Handle DNF specially
            if (rank === "DNF") {
                medalRank.innerText = "DNF";
                color = '#ff4444';
            }
            
            medalEl.style.backgroundColor = color;
            
            // Special message for 1st place
            if (rank === 1) {
                if (isMultiplayer) {
                    medalMsg.innerText = "1st place!";
                } else {
                    const diffName = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
                    let winMsg = `Congrats! You beat ${diffName}!`;
                    if (difficulty === 'matty') {
                        winMsg += "\nWant a medal bro?";
                    }
                    medalMsg.innerText = winMsg;
                }
                // Explode Confetti
                confettiParticles.forEach(c => c.explode());
            } 
            else if (rank === "DNF") {
                 // Already handled by wall collision msg setting, but ensure safety
            }
            else {
                medalMsg.innerText = "Unlucky pal, stick to college work";
            }
            
            if (isMultiplayer && gameState !== 'finished') {
                medalMsg.innerText += "\nWaiting for others...";
            }
        }

        function isClearAstern(behind, ahead) {
            // Transform 'behind' position into 'ahead' local space (aligned with heading)
            // Project vector (behind - ahead) onto ahead's heading vector
            // Heading 0 is Up (0, -1). Vector is (sin(h), -cos(h))
            // We want projection onto BACKWARD vector (Stern direction).
            // Backward vector is opposite of heading? 
            // Heading is forward. Stern is at +radius along "Back" axis?
            // Wait, draw() says: moveTo(0, -radius) [Bow], lineTo(0, radius) [Stern].
            // So in Local Draw Space: Y+ is Back.
            // Heading angle rotates this space.
            // So Stern vector direction is essentially same as Heading vector reversed?
            // Actually, Canvas rotate(h) rotates +Y axis to Heading angle? No.
            // Canvas coord system: +Y is Down.
            // Heading 0: Rotation 0. Boat drawn upright. Bow at -r (Up), Stern at +r (Down).
            // So if Heading is 0, Stern points Down (+Y).
            // So Stern Vector is (sin(h), -cos(h)) rotated 180?
            // Actually, simpler:
            // "Forward" unit vector: dx = sin(h), dy = -cos(h).
            // Project (B - A) onto Forward vector.
            // distFwd = (bx-ax)*sin(h) + (by-ay)*(-cos(h))
            // Stern is at distFwd = -radius.
            // "Behind stern line" means distFwd < -radius.
            
            const dx = behind.x - ahead.x;
            const dy = behind.y - ahead.y;
            const fwdX = Math.sin(ahead.heading);
            const fwdY = -Math.cos(ahead.heading);
            
            const distFwd = dx * fwdX + dy * fwdY;
            
            return distFwd < -ahead.radius;
        }

        function drawSmallRedFlag(ctx, x, y) {
            ctx.save();
            ctx.translate(x, y);
            ctx.fillStyle = '#ff4444';
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            
            // Flag pole
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -20);
            ctx.stroke();
            
            // Flag
            ctx.beginPath();
            ctx.moveTo(0, -20);
            ctx.lineTo(12, -15);
            ctx.lineTo(0, -10);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            ctx.restore();
        }

        function dsqBoat(boat, reason = "Rule 10: Starboard has right of way.") {
            if (boat.dsq || boat.finished) return;
            
            // Apply DSQ state locally first (for Host)
            boat.dsq = true;
            boat.moving = false;
            boat.dsqReason = reason; // Store reason for syncing

            if (boat.isUser) {
                if (GOD_MODE) {
                     boat.dsq = false;
                     boat.moving = true;
                     return; 
                }
                if (!isMultiplayer) gameState = 'finished';
                medalEl.style.display = 'flex';
                medalRank.innerText = "DSQ";
                medalMsg.innerText = reason;
                medalEl.style.backgroundColor = '#ff4444'; 
                sfx.playStartGun();
                
                if (isMultiplayer) {
                    medalMsg.innerText += "\nWaiting for others...";
                }
            } 
        }

        function polygonsIntersect(a, b) {
            const polygons = [a, b];
            for (let i = 0; i < polygons.length; i++) {
                const polygon = polygons[i];
                for (let j = 0; j < polygon.length; j++) {
                    const p1 = polygon[j];
                    const p2 = polygon[(j + 1) % polygon.length];
                    
                    const normal = { x: p2.y - p1.y, y: p1.x - p2.x };
                    
                    let minA = Infinity, maxA = -Infinity;
                    for (const p of a) {
                        const projected = normal.x * p.x + normal.y * p.y;
                        if (projected < minA) minA = projected;
                        if (projected > maxA) maxA = projected;
                    }
                    
                    let minB = Infinity, maxB = -Infinity;
                    for (const p of b) {
                        const projected = normal.x * p.x + normal.y * p.y;
                        if (projected < minB) minB = projected;
                        if (projected > maxB) maxB = projected;
                    }
                    
                    if (maxA < minB || maxB < minA) return false;
                }
            }
            return true;
        }

        function checkCollisions() {
            // Check every pair
            for (let i = 0; i < boats.length; i++) {
                for (let j = i + 1; j < boats.length; j++) {
                    const b1 = boats[i];
                    const b2 = boats[j];
                    
                    if (b1.finished || b1.dsq || b2.finished || b2.dsq) continue;
                    
                    const dx = b1.x - b2.x;
                    const dy = b1.y - b2.y;
                    const dist = Math.hypot(dx, dy);
                    
                    // Collision radius sum check (Broad Phase)
                    // Use 1.5 multiplier to ensure we catch corners of the triangle
                    if (dist < (b1.radius + b2.radius) * 1.5) {
                        // Narrow Phase: Polygon Intersection
                        const poly1 = b1.getPolygon();
                        const poly2 = b2.getPolygon();
                        
                        if (polygonsIntersect(poly1, poly2)) {
                            // Collision! Check Rules.
                            
                            // Rule 20: Room to Tack at Obstruction (Highest Priority)
                            // Check if b1 and b2 are part of a hailing chain.
                            // Case A: b1 is upstream of b2 (b1 -> ... -> b2). b2 (and downstream) is liable.
                            // Case B: b2 is upstream of b1 (b2 -> ... -> b1). b1 (and downstream) is liable.
                            
                            let upstreamBoat = null;
                            
                            // Check b1 -> b2 (Is b1 hailing b2 directly or indirectly?)
                            let curr = b1;
                            let loopGuard = 0;
                            while (curr.hailingTarget && loopGuard < 20) {
                                if (curr.hailingTarget === b2) {
                                    upstreamBoat = b1; 
                                    break;
                                }
                                curr = curr.hailingTarget;
                                loopGuard++;
                                if (curr === b1) break; 
                            }
                            
                            if (!upstreamBoat) {
                                // Check b2 -> b1
                                curr = b2;
                                loopGuard = 0;
                                while (curr.hailingTarget && loopGuard < 20) {
                                    if (curr.hailingTarget === b1) {
                                        upstreamBoat = b2;
                                        break;
                                    }
                                    curr = curr.hailingTarget;
                                    loopGuard++;
                                    if (curr === b2) break;
                                }
                            }
                            
                            if (upstreamBoat) {
                                // We found a chain relationship.
                                // The boat downstream (and the ultimate end of that chain) is liable.
                                // Trace from upstreamBoat to the very end of the chain.
                                
                                let chainEnd = upstreamBoat;
                                const visited = [];
                                while (chainEnd.hailingTarget) {
                                    if (visited.includes(chainEnd)) break;
                                    visited.push(chainEnd);
                                    chainEnd = chainEnd.hailingTarget;
                                }
                                
                                dsqBoat(chainEnd, "Failed to give room to tack! (Rule 20 Chain)");
                            }
                            
                            // Rule 13: While Tacking
                            else {
                                const b1Tacking = b1.isTackingRule();
                        const b2Tacking = b2.isTackingRule();
                        
                        if (b1Tacking || b2Tacking) {
                            if (b1Tacking && b2Tacking) {
                                // Both tacking: One on the left is in the wrong
                                if (b1.x < b2.x) dsqBoat(b1, "You were on the left while both tacking.");
                                else dsqBoat(b2, "You were on the left while both tacking.");
                            } else if (b1Tacking) {
                                // b1 is tacking -> b1 keeps clear
                                dsqBoat(b1, "You tacked too close! (Rule 13)");
                            } else {
                                // b2 is tacking -> b2 keeps clear
                                dsqBoat(b2, "You tacked too close! (Rule 13)");
                            }
                        }
                        // Case 1: Opposite Tacks (Rule 10)
                        else if (b1.tack !== b2.tack) {
                            // Starboard (-1) vs Port (1)
                            if (b1.tack === -1 && b2.tack === 1) {
                                dsqBoat(b2, "You were on Port! Starboard has right of way."); 
                            } else if (b1.tack === 1 && b2.tack === -1) {
                                dsqBoat(b1, "You were on Port! Starboard has right of way."); 
                            }
                        } 
                        // Case 2: Same Tack
                        else {
                            // Check Clear Astern
                            // Is b1 Clear Astern of b2?
                            if (isClearAstern(b1, b2)) {
                                dsqBoat(b1, "You hit them from behind! (Clear Astern)");
                            }
                            // Is b2 Clear Astern of b1?
                            else if (isClearAstern(b2, b1)) {
                                dsqBoat(b2, "You hit them from behind! (Clear Astern)");
                            }
                            // Overlap -> Windward keeps clear
                            else {
                                // Rotate positions to align with wind (Wind from Top = 0)
                                // Wind Direction 0 means wind comes from Top (0, -1 vector?) No, Arrow points Down.
                                // Code uses windDirection as rotation.
                                // If we rotate by -windDirection, wind is from Top (North).
                                
                                const x1 = b1.x * Math.cos(-windDirection) - b1.y * Math.sin(-windDirection);
                                const x2 = b2.x * Math.cos(-windDirection) - b2.y * Math.sin(-windDirection);
                                
                                // Starboard Tack (-1): Wind from Right. Windward is Max X.
                                if (b1.tack === -1) {
                                    if (x1 > x2) dsqBoat(b1, "You were Windward! (Rule 11)");
                                    else dsqBoat(b2, "You were Windward! (Rule 11)");
                                }
                                // Port Tack (1): Wind from Left. Windward is Min X.
                                else {
                                    if (x1 < x2) dsqBoat(b1, "You were Windward! (Rule 11)");
                                    else dsqBoat(b2, "You were Windward! (Rule 11)");
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    }

        function drawWindArrow(ctx) {
            // Draw a big arrow at the top center indicating wind from top
            const x = logicalWidth / 2; // Center horizontally
            const y = 60; // Slightly down from top
            const arrowLen = 40;
            
            ctx.save();
            ctx.translate(x, y);
            
            // Rotate based on windDirection.
            // windDirection 0 is From Top (arrow points down).
            // +windDirection means wind coming from East of North? 
            // In canvas, y is down. Math.sin(heading) moves +x (right).
            // Our boats move with heading 0 as UP. Wait.
            // Boat: dy = -cos(heading). dx = sin(heading). 
            // Heading 0 -> dy=-1 (Up), dx=0. So heading 0 is North.
            // Boat tack is +/- 40 deg.
            // If wind is 0 (North), boat heads +/- 40.
            
            // If wind shifts +10 deg (from NNE), it comes from slightly right.
            // Boat on starboard (+tack) must head +10 + 40 = +50.
            // Boat on port (-tack) must head +10 - 40 = -30.
            // This matches our formula: target = wind + tack*40.
            
            // Visualizing the Arrow:
            // Arrow points DOWN (with the wind).
            // If windDirection is 0, arrow points DOWN (PI).
            // If windDirection is +10 deg, wind blows towards South-West?
            // Wait. Wind direction usually means "FROM".
            // If wind is FROM 10 degrees (NNE), it blows TOWARDS 190 degrees (SSW).
            // So arrow rotation should be PI + windDirection.
            ctx.rotate(windDirection);

            // Wind is FROM top (North), so arrow points DOWN (South)
            // But usually "Wind Direction" arrows point into the wind?
            // "Wind from Top" -> Wind blows DOWN.
            // Let's draw an arrow pointing DOWN to show airflow direction.
            
            ctx.strokeStyle = 'white';
            ctx.fillStyle = 'white';
            ctx.lineWidth = 3;
            
            ctx.beginPath();
            ctx.moveTo(0, -arrowLen/2);
            ctx.lineTo(0, arrowLen/2);
            ctx.stroke();

            // Arrowhead at bottom
            ctx.beginPath();
            ctx.moveTo(0, arrowLen/2);
            ctx.lineTo(-10, arrowLen/2 - 10);
            ctx.lineTo(10, arrowLen/2 - 10);
            ctx.closePath();
            ctx.fill();

            // Text should remain upright-ish or rotate with arrow? 
            // Let's keep "WIND" label relative to arrow or fixed.
            // If we rotate context, text rotates. 
            // Let's draw text before rotation or untranslate.
            ctx.restore();
            
            // Draw text separately to keep it horizontal
            ctx.save();
            ctx.translate(x, y);
            ctx.fillStyle = 'white';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText("WIND", 0, -arrowLen/2 - 15);
            ctx.restore();
        }

        function drawStartLine(ctx) {
            // Only draw during starting phase
            if (gameState !== 'starting' && gameState !== 'waiting') return;
            
            // Draw a line near bottom where boats should stay behind
            const lineY = logicalHeight - 100; // 50px above startY usually
            
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 4;
            ctx.setLineDash([10, 10]); 
            ctx.beginPath();
            ctx.moveTo(0, lineY);
            ctx.lineTo(logicalWidth, lineY);
            ctx.stroke();
            ctx.setLineDash([]); 

            ctx.fillStyle = '#ffff00';
            ctx.textAlign = 'right';
            ctx.font = 'bold 16px sans-serif';
            ctx.fillText("START LINE", logicalWidth - 20, lineY - 10);
        }

        function drawFinishLine(ctx) {
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 4;
            ctx.setLineDash([20, 20]); // Dashed line
            ctx.beginPath();
            ctx.moveTo(0, FINISH_LINE_Y);
            ctx.lineTo(logicalWidth, FINISH_LINE_Y);
            ctx.stroke();
            ctx.setLineDash([]); // Reset

            // Label
            ctx.fillStyle = '#ff4444';
            ctx.textAlign = 'right';
            ctx.font = 'bold 20px sans-serif';
            ctx.fillText("FINISH", logicalWidth - 20, FINISH_LINE_Y - 10);
        }

        function applyWorldState(state) {
            // Update Global Vars
            windDirection = state.wind;
            
            // Sync Game State
            if (gameState !== state.gs) {
                gameState = state.gs;
                if (gameState === 'race_on') {
                    startTimerEl.innerText = "GO!";
                    // Host sets display none after "GO!".
                }
                else if (gameState === 'finished') {
                    // Update Medal Text if shown
                    if (medalEl.style.display === 'flex') {
                        // Keep current message but append Restart instruction?
                        // Or simple "Tap to Restart" button becomes active?
                        // Just refreshing the text if it contained "Waiting..."
                        const currentMsg = medalMsg.innerText;
                        if (currentMsg.includes("Waiting for others...")) {
                            if (isHost) {
                                medalMsg.innerText = currentMsg.replace("Waiting for others...", "Tap to Restart");
                            } else {
                                medalMsg.innerText = currentMsg.replace("Waiting for others...", "Waiting for Host to Restart...");
                            }
                        }
                    }
                }
            }
            
            // Sync Timer UI
            if (gameState === 'starting') {
                 // Clear waiting message
                 if (uiInstructions.innerText.includes("Waiting")) uiInstructions.innerText = "";
                 
                 startTimerEl.style.display = 'block';
                 startTimerEl.innerText = state.time;
            } else if (gameState === 'race_on') {
                 startTimerEl.innerText = "GO!";
            } else if (gameState === 'playing') {
                 startTimerEl.style.display = 'none';
            }

            // Sync Boats
            // Handle dynamic boat count (Client side)
            // If boat count mismatch, rebuild array? Or add/remove?
            // Rebuilding is easiest but trails might flicker. 
            // Better to update existing and add missing.
            
            // Mark all current boats as unseen
            const seenIds = new Set();
            
            state.boats.forEach(bData => {
                let boat = boats.find(b => b.id === bData.id);
                if (!boat) {
                    // New boat!
                    // Determine if it is ME
                    // My ID is stored in network.myId? No, that's Peer ID.
                    // We need the assigned game ID.
                    // We stored it in `myMultiplayerId`.
                    const isMe = (bData.id === myMultiplayerId);
                    boat = new Boat(bData.x, bData.y, isMe, bData.id);
                    boats.push(boat);
                }
                
                seenIds.add(bData.id);
                
                // Update properties
                boat.x = bData.x;
                boat.y = bData.y;
                boat.heading = bData.h;
                boat.targetHeading = bData.th || bData.h; // Sync Target Heading
                boat.tack = bData.t;
                
                // Check if JUST finished (Client Side Event)
                if (!boat.finished && bData.f) {
                     boat.finishRank = bData.fr; // Update rank
                     if (boat.isUser) {
                        let rank = boat.finishRank;
                        let suffix = 'th';
                        if (rank === 1) suffix = 'st';
                        else if (rank === 2) suffix = 'nd';
                        else if (rank === 3) suffix = 'rd';
                        endGame(rank, suffix);
                     }
                }
                
                // Check if JUST DSQ (Client Side Event) ‚Äì don't set boat.dsq before dsqBoat or it returns early and no medal shows
                if (!boat.dsq && bData.d) {
                    boat.dsqReason = bData.dr;
                    if (boat.isUser) {
                        dsqBoat(boat, boat.dsqReason || "Disqualified by Referee");
                    } else {
                        boat.dsq = true;
                        boat.moving = false;
                    }
                }

                // Check if JUST DNF / wall crash (Client Side Event)
                if (!boat.dnf && bData.dnf && (bData.id === myMultiplayerId)) {
                    gameState = 'finished';
                    medalEl.style.display = 'flex';
                    medalRank.innerText = "DNF";
                    medalMsg.innerText = "You hit a wall!";
                    if (isMultiplayer) medalMsg.innerText += "\nWaiting for others...";
                    medalEl.style.backgroundColor = '#ff4444';
                }

                boat.finished = bData.f;
                boat.finishRank = bData.fr; // Ensure sync
                boat.dsq = bData.d;
                boat.dsqReason = bData.dr;
                boat.dnf = bData.dnf;
                // FORCE OWNERSHIP SYNC
                // If myMultiplayerId is set, enforce it.
                if (isMultiplayer && myMultiplayerId !== null) {
                    boat.isUser = (bData.id === myMultiplayerId);
                } else {
                     boat.isUser = (bData.id === myMultiplayerId);
                }
            });
            
            // Remove boats that are gone (disconnected)
            for (let i = boats.length - 1; i >= 0; i--) {
                if (!seenIds.has(boats[i].id)) {
                    boats.splice(i, 1);
                }
            }

            // Sync Gusts (Full Replacement for exact sync)
            if (state.gusts) {
                // We can either try to match IDs or just replace the array.
                // Replacing array is easiest but might flicker if not smooth?
                // Actually, Gust objects are simple. 
                // Let's replace gusts list with new objects from state.
                
                // Optimization: Reuse objects if count matches to avoid GC?
                // For now, just rebuild. Gust count is low.
                
                gusts.length = 0;
                state.gusts.forEach(gData => {
                    gusts.push(new Gust(gData));
                });
            }
        }

        function gameLoop() {
            // Clear entire screen (physical)
            ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform for clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw Background (Sea)
            ctx.fillStyle = "#0077be";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Apply Scaling and Centering
            ctx.save();
            
            if (isMultiplayer) {
                const offsetX = (canvas.width - logicalWidth * scale) / 2;
                const offsetY = (canvas.height - logicalHeight * scale) / 2;
                ctx.translate(offsetX, offsetY);
                ctx.scale(scale, scale);
                
                // Clip to Game Area
                ctx.beginPath();
                ctx.rect(0, 0, logicalWidth, logicalHeight);
                ctx.clip();
                
                // Draw Border
                ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
                ctx.lineWidth = 2;
                ctx.strokeRect(0, 0, logicalWidth, logicalHeight);
            } else {
                // No scaling for single player (1:1 with screen)
                // logicalWidth/Height = width/height
            }

            // Draw Background Elements
            // Ripples first
            ripples.forEach(r => {
                r.update();
                r.draw(ctx);
            });
            
            drawFinishLine(ctx);
            // drawStartLine(ctx); // Removed
            drawWindArrow(ctx);

            // Wind Shift Logic
            if (gameState === 'playing' || gameState === 'starting') {
                // Smoothly interpolate windDirection to windTarget
                if (windDirection !== windTarget) {
                    const diff = windTarget - windDirection;
                    if (Math.abs(diff) < 0.005) {
                        windDirection = windTarget;
                    } else {
                        windDirection += diff * 0.05; // Ease to target
                    }
                }

                // Randomly pick new target
                if (Math.random() < WIND_SHIFT_CHANCE) {
                    const shift = (Math.random() - 0.5) * 2 * MAX_SHIFT;
                    // Bias towards center: The further out, the stronger the pull back
                    const centeringBias = -windTarget * 0.5;
                    
                    let newTarget = windTarget + shift + centeringBias;
                    // Clamp
                    if (newTarget > MAX_WIND_DEVIATION) newTarget = MAX_WIND_DEVIATION;
                    if (newTarget < -MAX_WIND_DEVIATION) newTarget = -MAX_WIND_DEVIATION;
                    windTarget = newTarget;
                }
            }
            
            // Audio: Modulate wind volume based on gusts/speed
            // Check if user is inside a gust
            let windVol = 0.05;
            const userBoat = boats.find(b => b.isUser);
            if (userBoat) {
                for (const g of gusts) {
                    if (g.active && 
                        userBoat.x >= g.x && userBoat.x <= g.x + g.width &&
                        userBoat.y >= g.y && userBoat.y <= g.y + g.height) {
                        windVol = 0.15; // Louder in gust
                        break;
                    }
                }
            }
            sfx.setWindVolume(windVol);

            // Gust Logic & Rendering (Draw under boats)
            if (gameState === 'playing' || gameState === 'race_on' || gameState === 'starting' || gameState === 'waiting') {
                // Spawn (Only Host or Offline)
                if (gameState !== 'waiting') {
                     if (!isMultiplayer || isHost) {
                        if (Math.random() < GUST_SPAWN_CHANCE) {
                            const g = new Gust();
                            gusts.push(g);
                            // Broadcast New Gust
                            if (isMultiplayer && network) {
                                network.broadcast({ 
                                    type: 'gust_spawn', 
                                    payload: {
                                        w: g.width,
                                        h: g.height,
                                        x: g.x,
                                        y: g.y,
                                        s: g.strength,
                                        id: Math.random() 
                                    }
                                });
                            }
                        }
                     }
                }
                
                // CLIENT GUST SYNC: 
                // If we are a client, we shouldn't rely solely on spawn events because of latency or missed packets.
                // However, synchronizing full gust array is heavy.
                // Let's add a periodic sync? Or just rely on spawn.
                // The issue "gusts aren't exactly the same" suggests drift or missing spawn.
                // Or simply that `update()` is running at different rates or times.
                // Since `update()` is purely `y += speed`, if frame rates differ, positions differ.
                // PeerJS is TCP-like (reliable ordered) so missing packets is less likely than timing drift.
                
                // Ideally, host sends Gust positions in the State packet.
                // Let's add gusts to the `state` payload broadcast.
                
                // Update & Draw
                for (let i = gusts.length - 1; i >= 0; i--) {
                    const g = gusts[i];
                    if (gameState !== 'waiting') g.update(); // Only move if game is active-ish
                    
                    // Draw active gusts
                    g.draw(ctx);

                    if (!g.active) {
                        gusts.splice(i, 1);
                    }
                }
            }

            // Update Boats only if playing or starting (for AI positioning/user mistakes)
            // CRITICAL: We also want to broadcast boat positions during 'waiting' phase so clients can see the lineup!
            
            if (gameState === 'playing' || gameState === 'race_on') {
                if (!isMultiplayer || isHost) {
                    boats.forEach(boat => boat.update());
                    checkCollisions();
                }
            }
            
            // Host Broadcast (Always, if boats exist, to keep lobby synced)
            if (isMultiplayer && isHost && network) {
                // Check Race End Condition
                if (gameState !== 'finished' && (gameState === 'playing' || gameState === 'race_on')) {
                    const allDone = boats.every(b => b.finished || b.dsq || b.dnf);
                    if (allDone && boats.length > 0) {
                        gameState = 'finished';
                    }
                }

                const state = {
                    boats: boats.map(b => ({
                        id: b.id,
                        x: b.x,
                        y: b.y,
                            h: b.heading,
                            th: b.targetHeading, // Sync Target Heading for turning logic
                            t: b.tack,
                            f: b.finished,
                        fr: b.finishRank, // Sync Rank
                        d: b.dsq,
                        dr: b.dsqReason, // Sync Reason
                        dnf: b.dnf // Send DNF state
                    })),
                    // Add Gusts to State for exact sync
                    gusts: gusts.map(g => ({
                        x: g.x,
                        y: g.y,
                        w: g.width,
                        h: g.height,
                        s: g.strength
                    })),
                    wind: windDirection,
                    time: startTimer,
                    gs: gameState
                };
                network.broadcast({ type: 'state', payload: state });
            }
            
            // Input logic remains...
            if (gameState === 'starting') {
                // Allow movement but check black flag
                // Actually, boats should stay still until tapped in previous logic. 
                // Now, user taps to start TIMER.
                // During timer, if user moves across line -> Black Flag.
                // AI should wait for timer.
                
                // Let's change input logic. 
                // Tap to start timer. Boats are frozen? Or can they sail?
                // "User has to tap once timer reaches 0". 
                // This implies user taps at 0 to GO. 
                // If they tap before 0? "if too soon they are told they got a Black Flag"
                // So tapping trigger the start. 
                
                // Revised Flow:
                // 1. Game loads 'waiting'. Tap to Start SEQUENCE.
                // 2. State 'starting'. Timer counts down 5..4..3..2..1..0.
                // 3. During countdown, input is ignored? No, "if too soon... Black Flag".
                // So tapping during countdown = Black Flag.
                // 4. At 0, State 'playing'. AI starts automatically. User must tap to start moving?
                // Or user taps at 0 to launch?
                // Usually sailing games: you sail pre-start.
                // "tap once the timer reaches 0" -> Tap to launch boat.
                
                // So during 'starting', boats are frozen at start line?
                // "if too soon they are told they got a Black Flag" -> Tapping during countdown = lose.
            }

            // Draw Boats
            boats.forEach(boat => boat.draw(ctx));
            
            // Draw Confetti
            confettiParticles.forEach(c => {
                c.update();
                c.draw(ctx);
            });
            
            if (isMultiplayer) {
                ctx.restore(); // Restore from Game Area Scale/Clip
            } else {
                ctx.restore(); // Restore from save() at start of Apply Scaling (even if empty)
            }

            // Draw UI Elements (Absolute Screen Coordinates if needed, or keeping them in game area)
            // UI like "GO!" or Medals are HTML overlay, so they handle themselves via CSS.
            // But we might want to center the HTML elements to the game area?
            // HTML elements are currently centered to window (50% left/top).
            // This is fine, they will overlay the game area correctly if it's also centered.
            
            // Wait, UI instructions like "Tap to Start" are HTML.
            // Medal is HTML.
            // Start Timer is HTML.
            // Canvas drawings (Wind Arrow, Lines) are inside scale. OK.

            requestAnimationFrame(gameLoop);
        }

        /* MOVED UP - Defined above now */
        // const startTimerEl = document.getElementById('start-timer');
        // const blackFlagMsg = document.getElementById('black-flag-msg');

        function startSequence() {
            gameState = 'starting';
            // uiInstructions.innerText = "Wait for 0..."; // Removed instruction, just timer
            uiInstructions.innerText = ""; 
            startTimer = 3;
            startTimerEl.style.display = 'block';
            startTimerEl.innerText = startTimer;
            sfx.playStartBeep(440);
            
            // Clear any existing interval
            if (startInterval) clearInterval(startInterval);
            
            startInterval = setInterval(() => {
                startTimer--;
                if (startTimer > 0) {
                    startTimerEl.innerText = startTimer;
                    sfx.playStartBeep(440 + (3-startTimer)*100); // Pitch up
                } else if (startTimer === 0) {
                    startTimerEl.innerText = "GO!";
                    sfx.playStartGun();
                    gameState = 'race_on'; 
                    launchAI();
                } else {
                    // Timer finished (negative), game is officially playable if not already
                    clearInterval(startInterval);
                    startTimerEl.style.display = 'none';
                    gameState = 'playing'; // So clients receive gs: 'playing' and hide "GO!" too
                }
            }, 1000);
        }

        function launchAI() {
            // Start all boats immediately
            boats.forEach(boat => {
                if (isMultiplayer) {
                    boat.moving = true;
                } else {
                    // Single Player: Start AI boats
                    if (!boat.isUser) {
                        boat.moving = true;
                    }
                }
            });
        }

        // Add moving flag to boat
        // Update Boat constructor to include moving = false
        // Update Boat.update to return if !this.moving

        // Input Handling Mapped to Logical Coordinates
        function getLogicalPos(evt) {
            const rect = canvas.getBoundingClientRect();
            // Touch vs Mouse
            const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
            const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
            
            const physX = clientX - rect.left;
            const physY = clientY - rect.top;
            
            // Inverse Scale/Translate
            let logicalX, logicalY;
            
            if (isMultiplayer) {
                const offsetX = (canvas.width - logicalWidth * scale) / 2;
                const offsetY = (canvas.height - logicalHeight * scale) / 2;
                logicalX = (physX - offsetX) / scale;
                logicalY = (physY - offsetY) / scale;
            } else {
                logicalX = physX;
                logicalY = physY;
            }
            
            return { x: logicalX, y: logicalY };
        }

        function handleInput(e) {
            sfx.init(); // Init audio context on first touch
            
            if (gameState === 'waiting') {
                if (isMultiplayer && !isHost) {
                    // Clients wait for host to start
                    // Do nothing
                } else {
                    startSequence();
                }
            } 
            else if (gameState === 'starting') {
                // User tapped during countdown!
                if (startTimer > 0) {
                    clearInterval(startInterval);
                    startTimerEl.style.display = 'none';
                    gameState = 'finished';
                    blackFlagMsg.style.display = 'block';
                    uiInstructions.innerText = "Tap to Restart";
                    // Fail state
                } else {
                    // Timer is 0 or race_on (though race_on usually handled by interval finish)
                    // If timer is 0 (GO displayed), valid start
                    // State becomes playing
                    gameState = 'playing';
                    uiInstructions.innerText = "Tap to Tack";
                    startTimerEl.style.display = 'none';
                    
                    // Find user boat and enable it
                    const userBoat = boats.find(b => b.isUser);
                    if (userBoat) {
                        userBoat.moving = true;
                    }
                    
                    // Also trigger AI if they haven't started (race_on handles it, but just in case)
                    if (startInterval) clearInterval(startInterval);
                    launchAI();
                    
                    // Show Eunice message if Will mode (delayed start)
                    if (difficulty === 'will') {
                        redFlagMsg.style.display = 'block';
                    }
                }
            }
            else if (gameState === 'race_on') {
                 // User tapped after GO disappeared (late start)
                 // NOTE: In multiplayer, 'race_on' is the global state broadcast by host when timer ends.
                 // Clients might be in 'race_on' state but haven't tapped locally yet.
                 
                 // If Client: Just tack.
                 if (isMultiplayer && !isHost) {
                      if (network) network.sendToHost({ type: 'tack' });
                 } else {
                     // Host/SP Logic:
                     gameState = 'playing';
                     uiInstructions.innerText = "Tap to Tack";
                     startTimerEl.style.display = 'none'; // Ensure timer is hidden
                     
                     const userBoat = boats.find(b => b.isUser);
                     if (userBoat) {
                         userBoat.moving = true;
                         // userBoat.tackBoat(); // REMOVED: Don't tack on the first tap that starts the race
                     }
                     
                     if (difficulty === 'will') {
                            redFlagMsg.style.display = 'block';
                     }
                 }
            }
            else if (gameState === 'playing') {
                const userBoat = boats.find(b => b.isUser);
                if (userBoat) {
                    if (isMultiplayer && !isHost) {
                        // Client: Send Tack Request
                        if (network) network.sendToHost({ type: 'tack' });
                    } else {
                        // Host or Single Player: Act locally
                        userBoat.tackBoat();
                    }
                } else if (isMultiplayer && !isHost) {
                    // Fallback: If 'isUser' check failed, maybe try sending tack anyway?
                    // This happens if boat.isUser logic is out of sync.
                    // Let's send a blind tack request, Host will validate ID.
                     if (network) network.sendToHost({ type: 'tack' });
                }
            } else if (gameState === 'finished') {
                if (isMultiplayer) {
                    if (isHost) {
                        // Host can restart
                        network.broadcast({ type: 'restart' });
                        resetGame();
                    } else {
                        // Client waits for host
                        // Do nothing
                    }
                } else {
                    resetGame();
                }
            }
        }

        window.addEventListener('mousedown', handleInput);
        window.addEventListener('touchstart', (e) => {
            // Check if touch target is UI
            if (e.target.closest('#settings-btn') || e.target.closest('#settings-modal')) {
                return;
            }
            e.preventDefault();
            handleInput(e);
        }, { passive: false });

        const medalEl = document.getElementById('medal');
        const medalRank = document.getElementById('medal-rank');
        const medalMsg = document.getElementById('medal-msg');
        const redFlagMsg = document.getElementById('red-flag-msg');
        const settingsBtn = document.getElementById('settings-btn');
        const settingsModal = document.getElementById('settings-modal');
        const saveBtn = document.getElementById('save-btn');
        const optSpeed = document.getElementById('opt-speed');
        const optSpeedVal = document.getElementById('opt-speed-val');
        const optBoats = document.getElementById('opt-boats');
        const optBoatsVal = document.getElementById('opt-boats-val');
        const optDiff = document.getElementById('opt-diff');
        const optSound = document.getElementById('opt-sound');
        const startTimerEl = document.getElementById('start-timer');
        const blackFlagMsg = document.getElementById('black-flag-msg');

        function updateSettingsUI() {
            // optSpeedVal.innerText = parseFloat(optSpeed.value).toFixed(2); // Removed display
            optBoatsVal.innerText = optBoats.value;
        }

        const advancedSettings = document.getElementById('advanced-settings');
        const customSpeed = document.getElementById('custom-speed');
        const customBoats = document.getElementById('custom-boats');
        const customRadius = document.getElementById('custom-radius');
        const chaosMode = document.getElementById('chaos-mode');
        const godMode = document.getElementById('god-mode');

        function openSettings(isAdvanced) {
            // Load current values
            optSpeed.value = BOAT_SPEED;
            optBoats.value = boatCount;
            optDiff.value = difficulty;
            optSound.checked = soundEnabled;
            updateSettingsUI();
            
            // Reset custom inputs
            customSpeed.value = '';
            customBoats.value = '';
            customRadius.value = '';
            chaosMode.checked = false;
            godMode.checked = false;

            if (isAdvanced) {
                advancedSettings.style.display = 'block';
                customSpeed.value = BOAT_SPEED;
                customBoats.value = boatCount;
                customRadius.value = BOAT_RADIUS;
                chaosMode.checked = (WIND_SHIFT_CHANCE > 0.01); // Simple check
                godMode.checked = GOD_MODE;
            } else {
                advancedSettings.style.display = 'none';
            }
            
            settingsModal.style.display = 'block';
        }

        let settingsTimer = null;
        let longPressTriggered = false;

        const startPress = (e) => {
            e.stopPropagation();
            longPressTriggered = false;
            settingsTimer = setTimeout(() => {
                longPressTriggered = true;
                openSettings(true);
            }, 1000); // 1 second hold for advanced
        };

        const endPress = (e) => {
            e.stopPropagation();
            if (settingsTimer) {
                clearTimeout(settingsTimer);
                settingsTimer = null;
            }
            if (!longPressTriggered) {
                openSettings(false);
            }
            longPressTriggered = false;
        };

        settingsBtn.addEventListener('mousedown', startPress);
        settingsBtn.addEventListener('mouseup', endPress);
        settingsBtn.addEventListener('mouseleave', (e) => {
             // If mouse leaves button while holding, cancel
             if (settingsTimer) {
                clearTimeout(settingsTimer);
                settingsTimer = null;
                longPressTriggered = false;
             }
        });

        settingsBtn.addEventListener('touchstart', (e) => {
            e.preventDefault(); // prevent mouse emulation
            startPress(e);
        });
        settingsBtn.addEventListener('touchend', endPress);
        
        settingsBtn.addEventListener('click', (e) => e.stopPropagation());

        optSpeed.addEventListener('input', updateSettingsUI);
        optBoats.addEventListener('input', updateSettingsUI);

        saveBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            
            // Check custom values first
            if (advancedSettings.style.display === 'block') {
                if (customSpeed.value && customSpeed.value.trim() !== "") {
                    BOAT_SPEED = parseFloat(customSpeed.value);
                } else {
                    BOAT_SPEED = parseFloat(optSpeed.value);
                }
                
                if (customBoats.value && customBoats.value.trim() !== "") {
                    boatCount = parseInt(customBoats.value);
                } else {
                    boatCount = parseInt(optBoats.value);
                }

                if (customRadius.value && customRadius.value.trim() !== "") {
                    BOAT_RADIUS = parseFloat(customRadius.value);
                } else {
                    BOAT_RADIUS = 15;
                }

                if (chaosMode.checked) {
                    WIND_SHIFT_CHANCE = 0.05; // 10x normal
                    MAX_SHIFT = 90 * Math.PI / 180; // 90 degree shifts
                } else {
                    WIND_SHIFT_CHANCE = 0.005;
                    MAX_SHIFT = 20 * Math.PI / 180;
                }

                GOD_MODE = godMode.checked;

            } else {
                BOAT_SPEED = parseFloat(optSpeed.value);
                boatCount = parseInt(optBoats.value);
                // Reset defaults if not in advanced
                BOAT_RADIUS = 15;
                WIND_SHIFT_CHANCE = 0.005;
                MAX_SHIFT = 20 * Math.PI / 180;
                GOD_MODE = false;
            }

            difficulty = optDiff.value;
            soundEnabled = optSound.checked;

            settingsModal.style.display = 'none';
            resetGame();
        });
        
        // Prevent clicks in modal from triggering game
        settingsModal.addEventListener('mousedown', (e) => e.stopPropagation());
        settingsModal.addEventListener('touchstart', (e) => e.stopPropagation());

        // Multiplayer UI Handlers
        const mpHostBtn = document.getElementById('mp-host-btn');
        const mpJoinBtn = document.getElementById('mp-join-btn');
        const mpJoinId = document.getElementById('mp-join-id');

        mpHostBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // prevent game start underneath
            if (mpStatus !== 'offline') return; // Prevent multiple clicks

            mpStatus = 'connecting';
            mpHostBtn.disabled = true;
            mpJoinBtn.disabled = true;
            mpJoinId.disabled = true;

            isMultiplayer = true;
            isHost = true;
            myMultiplayerId = 0; // Host is 0
            
            if (!network) network = new NetworkManager();
            network.init();
            
            // Apply MP Resolution and Reset
            resize(); 
            resetGame();

            updateMpStatus('Initializing Host...', 'yellow');
        });

        mpJoinBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (mpStatus !== 'offline') return; // Prevent multiple clicks

            const hostId = mpJoinId.value.trim().toUpperCase();
            if (!hostId) return;
            
            mpStatus = 'connecting';
            mpHostBtn.disabled = true;
            mpJoinBtn.disabled = true;
            mpJoinId.disabled = true;
            
            isMultiplayer = true;
            isHost = false;

            if (!network) network = new NetworkManager();
            network.connectTo(hostId);

            // Apply MP Resolution and Reset
            resize(); 
            resetGame();
        });

        init();
    </script>
</body>
</html>